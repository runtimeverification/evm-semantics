Proof CREATE_3_SPEC Failed

┌─ 1 (root, split, init)
│   k: #next [ CREATE ] ~> K_CELL:K
│   pc: PC_CELL:Int
│   callDepth: CALLDEPTH_CELL:Int
│   statusCode: STATUSCODE_CELL:StatusCode
┃
┃ (branch)
┣━━┓ subst: .Subst
┃  ┃ constraint:
┃  ┃     ( notBool STATIC_CELL:Bool )
┃  │
┃  ├─ 3
┃  │   k: #next [ CREATE ] ~> K_CELL:K
┃  │   pc: PC_CELL:Int
┃  │   callDepth: CALLDEPTH_CELL:Int
┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  │
┃  │  (4 steps)
┃  ├─ 5 (split)
┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃  │   pc: PC_CELL:Int
┃  │   callDepth: CALLDEPTH_CELL:Int
┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┃ (branch)
┃  ┣━━┓ subst: .Subst
┃  ┃  ┃ constraint:
┃  ┃  ┃     ID_CELL:Int ==Int WO:Int
┃  ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃  ┃  │
┃  ┃  ├─ 7
┃  ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  │
┃  ┃  │  (3 steps)
┃  ┃  ├─ 10 (split)
┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┃ (branch)
┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃  ┃  ┃  │
┃  ┃  ┃  ├─ 15
┃  ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  │
┃  ┃  ┃  │  (13 steps)
┃  ┃  ┃  ├─ 120
┃  ┃  ┃  │   k: K_CELL:K
┃  ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃  ┃  ┃  │
┃  ┃  ┃  ┊  constraint:
┃  ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃  ┃  ┊  subst: ...
┃  ┃  ┃  └─ 2 (leaf, target)
┃  ┃  ┃      k: K_CELL:K
┃  ┃  ┃      pc: FINAL_PC_CELL:Int
┃  ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┗━━┓ subst: .Subst
┃  ┃     ┃ constraint:
┃  ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃  ┃     │
┃  ┃     ├─ 16
┃  ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃  ┃     │   pc: PC_CELL:Int
┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     │
┃  ┃     │  (1 step)
┃  ┃     ├─ 20 (split)
┃  ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃  ┃     │   pc: PC_CELL:Int
┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃
┃  ┃     ┃ (branch)
┃  ┃     ┣━━┓ subst: .Subst
┃  ┃     ┃  ┃ constraint:
┃  ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃  ┃     ┃  │
┃  ┃     ┃  ├─ 31
┃  ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃  ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃  │
┃  ┃     ┃  │  (1 step)
┃  ┃     ┃  ├─ 51 (split)
┃  ┃     ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃  ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃  ┃
┃  ┃     ┃  ┃ (branch)
┃  ┃     ┃  ┣━━┓ subst: .Subst
┃  ┃     ┃  ┃  ┃ constraint:
┃  ┃     ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃  ┃     ┃  ┃  │
┃  ┃     ┃  ┃  ├─ 67
┃  ┃     ┃  ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃  ┃     ┃  ┃  │   pc: PC_CELL:Int
┃  ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃  ┃  │
┃  ┃     ┃  ┃  │  (11 steps)
┃  ┃     ┃  ┃  ├─ 156
┃  ┃     ┃  ┃  │   k: K_CELL:K
┃  ┃     ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃  ┃  │   statusCode: EVMC_NONCE_EXCEEDED
┃  ┃     ┃  ┃  │
┃  ┃     ┃  ┃  ┊  constraint:
┃  ┃     ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃     ┃  ┃  ┊  subst: ...
┃  ┃     ┃  ┃  └─ 2 (leaf, target)
┃  ┃     ┃  ┃      k: K_CELL:K
┃  ┃     ┃  ┃      pc: FINAL_PC_CELL:Int
┃  ┃     ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃     ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃     ┃  ┃
┃  ┃     ┃  ┗━━┓ subst: .Subst
┃  ┃     ┃     ┃ constraint:
┃  ┃     ┃     ┃     0 <=Int NONCE_CELL:Int
┃  ┃     ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃  ┃     ┃     │
┃  ┃     ┃     ├─ 68
┃  ┃     ┃     │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃  ┃     ┃     │   pc: PC_CELL:Int
┃  ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     │
┃  ┃     ┃     │  (5 steps)
┃  ┃     ┃     ├─ 94 (split)
┃  ┃     ┃     │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃     │   pc: PC_CELL:Int
┃  ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃
┃  ┃     ┃     ┃ (branch)
┃  ┃     ┃     ┣━━┓ subst: .Subst
┃  ┃     ┃     ┃  ┃ constraint:
┃  ┃     ┃     ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃  ┃     ┃     ┃  │
┃  ┃     ┃     ┃  ├─ 124
┃  ┃     ┃     ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  │
┃  ┃     ┃     ┃  │  (10 steps)
┃  ┃     ┃     ┃  ├─ 280
┃  ┃     ┃     ┃  │   k: K_CELL:K
┃  ┃     ┃     ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  │   statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃     ┃  │
┃  ┃     ┃     ┃  ┊  constraint:
┃  ┃     ┃     ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃     ┃     ┃  ┊  subst: ...
┃  ┃     ┃     ┃  └─ 2 (leaf, target)
┃  ┃     ┃     ┃      k: K_CELL:K
┃  ┃     ┃     ┃      pc: FINAL_PC_CELL:Int
┃  ┃     ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃
┃  ┃     ┃     ┣━━┓ subst: .Subst
┃  ┃     ┃     ┃  ┃ constraint:
┃  ┃     ┃     ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃     ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃  ┃     ┃     ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃     ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃  ┃     ┃     ┃  │
┃  ┃     ┃     ┃  ├─ 125
┃  ┃     ┃     ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  │
┃  ┃     ┃     ┃  │  (1 step)
┃  ┃     ┃     ┃  ├─ 168
┃  ┃     ┃     ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃  ┃ (1 step)
┃  ┃     ┃     ┃  ┣━━┓
┃  ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ├─ 215
┃  ┃     ┃     ┃  ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃     ┃  ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃  ┃  │  (11 steps)
┃  ┃     ┃     ┃  ┃  ├─ 287
┃  ┃     ┃     ┃  ┃  │   k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃  ┃  │   pc: 0
┃  ┃     ┃     ┃  ┃  │   callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  ┃
┃  ┃     ┃     ┃  ┃  ┃ (1 step)
┃  ┃     ┃     ┃  ┃  ┣━━┓
┃  ┃     ┃     ┃  ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ┃  └─ 371 (leaf, pending)
┃  ┃     ┃     ┃  ┃  ┃      k: #end EVMC_STACK_UNDERFLOW ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_ ...
┃  ┃     ┃     ┃  ┃  ┃      pc: 0
┃  ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  ┃
┃  ┃     ┃     ┃  ┃  ┣━━┓
┃  ┃     ┃     ┃  ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ┃  └─ 372 (leaf, pending)
┃  ┃     ┃     ┃  ┃  ┃      k: #end EVMC_STACK_OVERFLOW ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_C ...
┃  ┃     ┃     ┃  ┃  ┃      pc: 0
┃  ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  ┃
┃  ┃     ┃     ┃  ┃  ┣━━┓
┃  ┃     ┃     ┃  ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ┃  └─ 373 (leaf, pending)
┃  ┃     ┃     ┃  ┃  ┃      k: #addr [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃  ┃  ┃      pc: 0
┃  ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  ┃
┃  ┃     ┃     ┃  ┃  ┣━━┓
┃  ┃     ┃     ┃  ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ┃  └─ 374 (leaf, pending)
┃  ┃     ┃     ┃  ┃  ┃      k: #end EVMC_SUCCESS ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int ...
┃  ┃     ┃     ┃  ┃  ┃      pc: 0
┃  ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  ┃
┃  ┃     ┃     ┃  ┃  ┗━━┓
┃  ┃     ┃     ┃  ┃     │
┃  ┃     ┃     ┃  ┃     └─ 375 (leaf, pending)
┃  ┃     ┃     ┃  ┃         k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃  ┃         pc: 0
┃  ┃     ┃     ┃  ┃         callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃  ┣━━┓
┃  ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ├─ 216
┃  ┃     ┃     ┃  ┃  │   k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃     ┃  ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃  ┃  │  (8 steps)
┃  ┃     ┃     ┃  ┃  ├─ 367
┃  ┃     ┃     ┃  ┃  │   k: K_CELL:K
┃  ┃     ┃     ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  ┃  │   statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃  ┃  ┊  constraint:
┃  ┃     ┃     ┃  ┃  ┊      ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃     ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃     ┃  ┃  ┊      ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃  ┃     ┃     ┃  ┃  ┊  subst: ...
┃  ┃     ┃     ┃  ┃  └─ 2 (leaf, target)
┃  ┃     ┃     ┃  ┃      k: K_CELL:K
┃  ┃     ┃     ┃  ┃      pc: FINAL_PC_CELL:Int
┃  ┃     ┃     ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃  ┗━━┓
┃  ┃     ┃     ┃     │
┃  ┃     ┃     ┃     ├─ 217
┃  ┃     ┃     ┃     │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃     ┃     │   pc: PC_CELL:Int
┃  ┃     ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃
┃  ┃     ┃     ┃     ┃ (1 step)
┃  ┃     ┃     ┃     ┣━━┓
┃  ┃     ┃     ┃     ┃  │
┃  ┃     ┃     ┃     ┃  ├─ 281
┃  ┃     ┃     ┃     ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃     ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  │
┃  ┃     ┃     ┃     ┃  │  (11 steps)
┃  ┃     ┃     ┃     ┃  ├─ 366
┃  ┃     ┃     ┃     ┃  │   k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃     ┃  │   pc: 0
┃  ┃     ┃     ┃     ┃  │   callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃     ┃  ┃ (1 step)
┃  ┃     ┃     ┃     ┃  ┣━━┓
┃  ┃     ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃     ┃  ┃  └─ 478 (leaf, pending)
┃  ┃     ┃     ┃     ┃  ┃      k: #end EVMC_STACK_UNDERFLOW ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_ ...
┃  ┃     ┃     ┃     ┃  ┃      pc: 0
┃  ┃     ┃     ┃     ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃     ┃  ┣━━┓
┃  ┃     ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃     ┃  ┃  └─ 479 (leaf, pending)
┃  ┃     ┃     ┃     ┃  ┃      k: #end EVMC_STACK_OVERFLOW ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_C ...
┃  ┃     ┃     ┃     ┃  ┃      pc: 0
┃  ┃     ┃     ┃     ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃     ┃  ┣━━┓
┃  ┃     ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃     ┃  ┃  └─ 480 (leaf, pending)
┃  ┃     ┃     ┃     ┃  ┃      k: #addr [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃     ┃  ┃      pc: 0
┃  ┃     ┃     ┃     ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃     ┃  ┣━━┓
┃  ┃     ┃     ┃     ┃  ┃  │
┃  ┃     ┃     ┃     ┃  ┃  └─ 481 (leaf, pending)
┃  ┃     ┃     ┃     ┃  ┃      k: #end EVMC_SUCCESS ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int ...
┃  ┃     ┃     ┃     ┃  ┃      pc: 0
┃  ┃     ┃     ┃     ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  ┃
┃  ┃     ┃     ┃     ┃  ┗━━┓
┃  ┃     ┃     ┃     ┃     │
┃  ┃     ┃     ┃     ┃     └─ 482 (leaf, pending)
┃  ┃     ┃     ┃     ┃         k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃     ┃         pc: 0
┃  ┃     ┃     ┃     ┃         callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃
┃  ┃     ┃     ┃     ┣━━┓
┃  ┃     ┃     ┃     ┃  │
┃  ┃     ┃     ┃     ┃  ├─ 282
┃  ┃     ┃     ┃     ┃  │   k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃     ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃     ┃  │
┃  ┃     ┃     ┃     ┃  │  (8 steps)
┃  ┃     ┃     ┃     ┃  └─ 454 (leaf, pending)
┃  ┃     ┃     ┃     ┃      k: K_CELL:K
┃  ┃     ┃     ┃     ┃      pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃     ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃     ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃     ┃     ┃
┃  ┃     ┃     ┃     ┗━━┓
┃  ┃     ┃     ┃        │
┃  ┃     ┃     ┃        ├─ 283
┃  ┃     ┃     ┃        │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃     ┃        │   pc: PC_CELL:Int
┃  ┃     ┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃        ┃
┃  ┃     ┃     ┃        ┃ (1 step)
┃  ┃     ┃     ┃        ┣━━┓
┃  ┃     ┃     ┃        ┃  │
┃  ┃     ┃     ┃        ┃  ├─ 363
┃  ┃     ┃     ┃        ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃     ┃        ┃  │   pc: PC_CELL:Int
┃  ┃     ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃        ┃  │
┃  ┃     ┃     ┃        ┃  │  (11 steps)
┃  ┃     ┃     ┃        ┃  └─ 474 (leaf, pending)
┃  ┃     ┃     ┃        ┃      k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃     ┃        ┃      pc: 0
┃  ┃     ┃     ┃        ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃     ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃        ┃
┃  ┃     ┃     ┃        ┣━━┓
┃  ┃     ┃     ┃        ┃  │
┃  ┃     ┃     ┃        ┃  └─ 364 (leaf, pending)
┃  ┃     ┃     ┃        ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃     ┃        ┃      pc: PC_CELL:Int
┃  ┃     ┃     ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃        ┃
┃  ┃     ┃     ┃        ┗━━┓
┃  ┃     ┃     ┃           │
┃  ┃     ┃     ┃           ├─ 365
┃  ┃     ┃     ┃           │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃     ┃           │   pc: PC_CELL:Int
┃  ┃     ┃     ┃           │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃           ┃
┃  ┃     ┃     ┃           ┃ (1 step)
┃  ┃     ┃     ┃           ┣━━┓
┃  ┃     ┃     ┃           ┃  │
┃  ┃     ┃     ┃           ┃  └─ 475 (leaf, pending)
┃  ┃     ┃     ┃           ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃     ┃           ┃      pc: PC_CELL:Int
┃  ┃     ┃     ┃           ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃           ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃           ┃
┃  ┃     ┃     ┃           ┣━━┓
┃  ┃     ┃     ┃           ┃  │
┃  ┃     ┃     ┃           ┃  └─ 476 (leaf, pending)
┃  ┃     ┃     ┃           ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃     ┃           ┃      pc: PC_CELL:Int
┃  ┃     ┃     ┃           ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃           ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃           ┃
┃  ┃     ┃     ┃           ┗━━┓
┃  ┃     ┃     ┃              │
┃  ┃     ┃     ┃              └─ 477 (leaf, pending)
┃  ┃     ┃     ┃                  k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃     ┃                  pc: PC_CELL:Int
┃  ┃     ┃     ┃                  callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃     ┃                  statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃     ┃
┃  ┃     ┃     ┗━━┓ subst: .Subst
┃  ┃     ┃        ┃ constraint: true
┃  ┃     ┃        │
┃  ┃     ┃        ├─ 126 (split)
┃  ┃     ┃        │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃        │   pc: PC_CELL:Int
┃  ┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃
┃  ┃     ┃        ┃ (branch)
┃  ┃     ┃        ┣━━┓ subst: .Subst
┃  ┃     ┃        ┃  ┃ constraint:
┃  ┃     ┃        ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃  ┃     ┃        ┃  │
┃  ┃     ┃        ┃  ├─ 169
┃  ┃     ┃        ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃        ┃  │   pc: PC_CELL:Int
┃  ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃  │
┃  ┃     ┃        ┃  │  (10 steps)
┃  ┃     ┃        ┃  ├─ 300
┃  ┃     ┃        ┃  │   k: K_CELL:K
┃  ┃     ┃        ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  │   statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃        ┃  │
┃  ┃     ┃        ┃  ┊  constraint:
┃  ┃     ┃        ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃     ┃        ┃  ┊  subst: ...
┃  ┃     ┃        ┃  └─ 2 (leaf, target)
┃  ┃     ┃        ┃      k: K_CELL:K
┃  ┃     ┃        ┃      pc: FINAL_PC_CELL:Int
┃  ┃     ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃
┃  ┃     ┃        ┣━━┓ subst: .Subst
┃  ┃     ┃        ┃  ┃ constraint:
┃  ┃     ┃        ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃        ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃  ┃     ┃        ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃        ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃  ┃     ┃        ┃  │
┃  ┃     ┃        ┃  ├─ 170
┃  ┃     ┃        ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃        ┃  │   pc: PC_CELL:Int
┃  ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃  │
┃  ┃     ┃        ┃  │  (1 step)
┃  ┃     ┃        ┃  ├─ 219
┃  ┃     ┃        ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃        ┃  │   pc: PC_CELL:Int
┃  ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃  ┃
┃  ┃     ┃        ┃  ┃ (1 step)
┃  ┃     ┃        ┃  ┣━━┓
┃  ┃     ┃        ┃  ┃  │
┃  ┃     ┃        ┃  ┃  ├─ 284
┃  ┃     ┃        ┃  ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃        ┃  ┃  │   pc: PC_CELL:Int
┃  ┃     ┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃  ┃  │
┃  ┃     ┃        ┃  ┃  │  (11 steps)
┃  ┃     ┃        ┃  ┃  └─ 376 (leaf, pending)
┃  ┃     ┃        ┃  ┃      k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃        ┃  ┃      pc: 0
┃  ┃     ┃        ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃        ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃  ┃
┃  ┃     ┃        ┃  ┣━━┓
┃  ┃     ┃        ┃  ┃  │
┃  ┃     ┃        ┃  ┃  ├─ 285
┃  ┃     ┃        ┃  ┃  │   k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃        ┃  ┃  │   pc: PC_CELL:Int
┃  ┃     ┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃  ┃  │
┃  ┃     ┃        ┃  ┃  │  (8 steps)
┃  ┃     ┃        ┃  ┃  └─ 460 (leaf, pending)
┃  ┃     ┃        ┃  ┃      k: K_CELL:K
┃  ┃     ┃        ┃  ┃      pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃        ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃  ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃        ┃  ┃
┃  ┃     ┃        ┃  ┗━━┓
┃  ┃     ┃        ┃     │
┃  ┃     ┃        ┃     ├─ 286
┃  ┃     ┃        ┃     │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃        ┃     │   pc: PC_CELL:Int
┃  ┃     ┃        ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃     ┃
┃  ┃     ┃        ┃     ┃ (1 step)
┃  ┃     ┃        ┃     ┣━━┓
┃  ┃     ┃        ┃     ┃  │
┃  ┃     ┃        ┃     ┃  ├─ 368
┃  ┃     ┃        ┃     ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃        ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃        ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃     ┃  │
┃  ┃     ┃        ┃     ┃  │  (11 steps)
┃  ┃     ┃        ┃     ┃  └─ 484 (leaf, pending)
┃  ┃     ┃        ┃     ┃      k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃  ┃     ┃        ┃     ┃      pc: 0
┃  ┃     ┃        ┃     ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃  ┃     ┃        ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃     ┃
┃  ┃     ┃        ┃     ┣━━┓
┃  ┃     ┃        ┃     ┃  │
┃  ┃     ┃        ┃     ┃  └─ 369 (leaf, pending)
┃  ┃     ┃        ┃     ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃        ┃     ┃      pc: PC_CELL:Int
┃  ┃     ┃        ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃     ┃
┃  ┃     ┃        ┃     ┗━━┓
┃  ┃     ┃        ┃        │
┃  ┃     ┃        ┃        ├─ 370
┃  ┃     ┃        ┃        │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃        ┃        │   pc: PC_CELL:Int
┃  ┃     ┃        ┃        │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃        ┃
┃  ┃     ┃        ┃        ┃ (1 step)
┃  ┃     ┃        ┃        ┣━━┓
┃  ┃     ┃        ┃        ┃  │
┃  ┃     ┃        ┃        ┃  └─ 485 (leaf, pending)
┃  ┃     ┃        ┃        ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃        ┃        ┃      pc: PC_CELL:Int
┃  ┃     ┃        ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃        ┃
┃  ┃     ┃        ┃        ┣━━┓
┃  ┃     ┃        ┃        ┃  │
┃  ┃     ┃        ┃        ┃  └─ 486 (leaf, pending)
┃  ┃     ┃        ┃        ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃        ┃        ┃      pc: PC_CELL:Int
┃  ┃     ┃        ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃        ┃
┃  ┃     ┃        ┃        ┗━━┓
┃  ┃     ┃        ┃           │
┃  ┃     ┃        ┃           └─ 487 (leaf, pending)
┃  ┃     ┃        ┃               k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃        ┃               pc: PC_CELL:Int
┃  ┃     ┃        ┃               callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃        ┃               statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃        ┃
┃  ┃     ┃        ┗━━┓ subst: .Subst
┃  ┃     ┃           ┃ constraint: true
┃  ┃     ┃           │
┃  ┃     ┃           ├─ 171 (split)
┃  ┃     ┃           │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃           │   pc: PC_CELL:Int
┃  ┃     ┃           │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃
┃  ┃     ┃           ┃ (branch)
┃  ┃     ┃           ┣━━┓ subst: .Subst
┃  ┃     ┃           ┃  ┃ constraint:
┃  ┃     ┃           ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃  ┃     ┃           ┃  │
┃  ┃     ┃           ┃  ├─ 220
┃  ┃     ┃           ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃           ┃  │   pc: PC_CELL:Int
┃  ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃  │
┃  ┃     ┃           ┃  │  (10 steps)
┃  ┃     ┃           ┃  ├─ 358
┃  ┃     ┃           ┃  │   k: K_CELL:K
┃  ┃     ┃           ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃  │   statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃           ┃  │
┃  ┃     ┃           ┃  ┊  constraint:
┃  ┃     ┃           ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃     ┃           ┃  ┊  subst: ...
┃  ┃     ┃           ┃  └─ 2 (leaf, target)
┃  ┃     ┃           ┃      k: K_CELL:K
┃  ┃     ┃           ┃      pc: FINAL_PC_CELL:Int
┃  ┃     ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃
┃  ┃     ┃           ┣━━┓ subst: .Subst
┃  ┃     ┃           ┃  ┃ constraint:
┃  ┃     ┃           ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃           ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃  ┃     ┃           ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃           ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃  ┃     ┃           ┃  │
┃  ┃     ┃           ┃  ├─ 221
┃  ┃     ┃           ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃           ┃  │   pc: PC_CELL:Int
┃  ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃  │
┃  ┃     ┃           ┃  │  (1 step)
┃  ┃     ┃           ┃  ├─ 288
┃  ┃     ┃           ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃           ┃  │   pc: PC_CELL:Int
┃  ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃  ┃
┃  ┃     ┃           ┃  ┃ (1 step)
┃  ┃     ┃           ┃  ┣━━┓
┃  ┃     ┃           ┃  ┃  │
┃  ┃     ┃           ┃  ┃  └─ 377 (leaf, pending)
┃  ┃     ┃           ┃  ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃  ┃     ┃           ┃  ┃      pc: PC_CELL:Int
┃  ┃     ┃           ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃  ┃
┃  ┃     ┃           ┃  ┣━━┓
┃  ┃     ┃           ┃  ┃  │
┃  ┃     ┃           ┃  ┃  └─ 378 (leaf, pending)
┃  ┃     ┃           ┃  ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃  ┃     ┃           ┃  ┃      pc: PC_CELL:Int
┃  ┃     ┃           ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃  ┃
┃  ┃     ┃           ┃  ┗━━┓
┃  ┃     ┃           ┃     │
┃  ┃     ┃           ┃     └─ 379 (leaf, pending)
┃  ┃     ┃           ┃         k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃           ┃         pc: PC_CELL:Int
┃  ┃     ┃           ┃         callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃           ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃           ┃
┃  ┃     ┃           ┗━━┓ subst: .Subst
┃  ┃     ┃              ┃ constraint: true
┃  ┃     ┃              │
┃  ┃     ┃              ├─ 222 (split)
┃  ┃     ┃              │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃              │   pc: PC_CELL:Int
┃  ┃     ┃              │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃              ┃
┃  ┃     ┃              ┃ (branch)
┃  ┃     ┃              ┣━━┓ subst: .Subst
┃  ┃     ┃              ┃  ┃ constraint:
┃  ┃     ┃              ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃  ┃     ┃              ┃  │
┃  ┃     ┃              ┃  ├─ 289
┃  ┃     ┃              ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃              ┃  │   pc: PC_CELL:Int
┃  ┃     ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃              ┃  │
┃  ┃     ┃              ┃  │  (10 steps)
┃  ┃     ┃              ┃  └─ 443 (leaf, pending)
┃  ┃     ┃              ┃      k: K_CELL:K
┃  ┃     ┃              ┃      pc: ( PC_CELL:Int +Int 1 )
┃  ┃     ┃              ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃              ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃  ┃     ┃              ┃
┃  ┃     ┃              ┣━━┓ subst: .Subst
┃  ┃     ┃              ┃  ┃ constraint:
┃  ┃     ┃              ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃              ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃  ┃     ┃              ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃              ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃  ┃     ┃              ┃  │
┃  ┃     ┃              ┃  ├─ 290
┃  ┃     ┃              ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃              ┃  │   pc: PC_CELL:Int
┃  ┃     ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃              ┃  │
┃  ┃     ┃              ┃  │  (1 step)
┃  ┃     ┃              ┃  └─ 380 (leaf, pending)
┃  ┃     ┃              ┃      k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃  ┃     ┃              ┃      pc: PC_CELL:Int
┃  ┃     ┃              ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃              ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃              ┃
┃  ┃     ┃              ┗━━┓ subst: .Subst
┃  ┃     ┃                 ┃ constraint: true
┃  ┃     ┃                 │
┃  ┃     ┃                 ├─ 291 (split)
┃  ┃     ┃                 │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃                 │   pc: PC_CELL:Int
┃  ┃     ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃                 ┃
┃  ┃     ┃                 ┃ (branch)
┃  ┃     ┃                 ┣━━┓ subst: .Subst
┃  ┃     ┃                 ┃  ┃ constraint:
┃  ┃     ┃                 ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃  ┃     ┃                 ┃  │
┃  ┃     ┃                 ┃  └─ 381 (leaf, pending)
┃  ┃     ┃                 ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃                 ┃      pc: PC_CELL:Int
┃  ┃     ┃                 ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃                 ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃                 ┃
┃  ┃     ┃                 ┣━━┓ subst: .Subst
┃  ┃     ┃                 ┃  ┃ constraint:
┃  ┃     ┃                 ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃                 ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃  ┃     ┃                 ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃     ┃                 ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃  ┃     ┃                 ┃  │
┃  ┃     ┃                 ┃  └─ 382 (leaf, pending)
┃  ┃     ┃                 ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃                 ┃      pc: PC_CELL:Int
┃  ┃     ┃                 ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃                 ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃                 ┃
┃  ┃     ┃                 ┗━━┓ subst: .Subst
┃  ┃     ┃                    ┃ constraint: true
┃  ┃     ┃                    │
┃  ┃     ┃                    └─ 383 (leaf, pending)
┃  ┃     ┃                        k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃  ┃     ┃                        pc: PC_CELL:Int
┃  ┃     ┃                        callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃                        statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃
┃  ┃     ┗━━┓ subst: .Subst
┃  ┃        ┃ constraint:
┃  ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃  ┃        │
┃  ┃        ├─ 32
┃  ┃        │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃  ┃        │   pc: PC_CELL:Int
┃  ┃        │   callDepth: CALLDEPTH_CELL:Int
┃  ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃        │
┃  ┃        │  (12 steps)
┃  ┃        ├─ 122
┃  ┃        │   k: K_CELL:K
┃  ┃        │   pc: ( PC_CELL:Int +Int 1 )
┃  ┃        │   callDepth: CALLDEPTH_CELL:Int
┃  ┃        │   statusCode: EVMC_CALL_DEPTH_EXCEEDED
┃  ┃        │
┃  ┃        ┊  constraint:
┃  ┃        ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃        ┊  subst: ...
┃  ┃        └─ 2 (leaf, target)
┃  ┃            k: K_CELL:K
┃  ┃            pc: FINAL_PC_CELL:Int
┃  ┃            callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃            statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┣━━┓ subst: .Subst
┃  ┃  ┃ constraint:
┃  ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃  ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃  ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃  ┃  │
┃  ┃  ├─ 8
┃  ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  │
┃  ┃  │  (3 steps)
┃  ┃  ├─ 11 (split)
┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┃ (branch)
┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃     BAL:Int <Int W0:Int
┃  ┃  ┃  │
┃  ┃  ┃  ├─ 17 (split)
┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ├─ 22 (split)
┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ├─ 37 (split)
┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ├─ 56 (split)
┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 81 (split)
┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 108 (split)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 145 (split)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 189 (split)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 241 (split)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 311 (split)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  └─ 403 (leaf, pending)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 404 (leaf, pending)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 312
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 242
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 190
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 146
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 109
┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃     ├─ 82
┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃     ├─ 57
┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃     ├─ 38
┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃  ┃     ┊      false
┃  ┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃  ┃     │
┃  ┃  ┃     ├─ 23
┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  ┃     │   pc: PC_CELL:Int
┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃     │
┃  ┃  ┃     ┊  constraint:
┃  ┃  ┃     ┊      false
┃  ┃  ┃     ┊  subst: .Subst
┃  ┃  ┃     └─ 2 (leaf, target)
┃  ┃  ┃         k: K_CELL:K
┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┗━━┓ subst: .Subst
┃  ┃     ┃ constraint:
┃  ┃     ┃     W0:Int <=Int BAL:Int
┃  ┃     │
┃  ┃     ├─ 18 (split)
┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃     │   pc: PC_CELL:Int
┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃
┃  ┃     ┃ (branch)
┃  ┃     ┣━━┓ subst: .Subst
┃  ┃     ┃  ┃ constraint:
┃  ┃     ┃  ┃     BAL:Int <Int W0:Int
┃  ┃     ┃  │
┃  ┃     ┃  ├─ 29
┃  ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃     ┃  │   pc: PC_CELL:Int
┃  ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     ┃  │
┃  ┃     ┃  ┊  constraint:
┃  ┃     ┃  ┊      false
┃  ┃     ┃  ┊  subst: .Subst
┃  ┃     ┃  └─ 2 (leaf, target)
┃  ┃     ┃      k: K_CELL:K
┃  ┃     ┃      pc: FINAL_PC_CELL:Int
┃  ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃     ┃
┃  ┃     ┗━━┓ subst: .Subst
┃  ┃        ┃ constraint: true
┃  ┃        │
┃  ┃        ├─ 30 (split)
┃  ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃        │   pc: PC_CELL:Int
┃  ┃        │   callDepth: CALLDEPTH_CELL:Int
┃  ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃        ┃
┃  ┃        ┃ (branch)
┃  ┃        ┣━━┓ subst: .Subst
┃  ┃        ┃  ┃ constraint:
┃  ┃        ┃  ┃     BAL:Int <Int W0:Int
┃  ┃        ┃  │
┃  ┃        ┃  ├─ 43
┃  ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃        ┃  │   pc: PC_CELL:Int
┃  ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃        ┃  │
┃  ┃        ┃  ┊  constraint:
┃  ┃        ┃  ┊      false
┃  ┃        ┃  ┊  subst: .Subst
┃  ┃        ┃  └─ 2 (leaf, target)
┃  ┃        ┃      k: K_CELL:K
┃  ┃        ┃      pc: FINAL_PC_CELL:Int
┃  ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃        ┃
┃  ┃        ┗━━┓ subst: .Subst
┃  ┃           ┃ constraint: true
┃  ┃           │
┃  ┃           ├─ 44 (split)
┃  ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃           │   pc: PC_CELL:Int
┃  ┃           │   callDepth: CALLDEPTH_CELL:Int
┃  ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃           ┃
┃  ┃           ┃ (branch)
┃  ┃           ┣━━┓ subst: .Subst
┃  ┃           ┃  ┃ constraint:
┃  ┃           ┃  ┃     BAL:Int <Int W0:Int
┃  ┃           ┃  │
┃  ┃           ┃  ├─ 63
┃  ┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃           ┃  │   pc: PC_CELL:Int
┃  ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃           ┃  │
┃  ┃           ┃  ┊  constraint:
┃  ┃           ┃  ┊      false
┃  ┃           ┃  ┊  subst: .Subst
┃  ┃           ┃  └─ 2 (leaf, target)
┃  ┃           ┃      k: K_CELL:K
┃  ┃           ┃      pc: FINAL_PC_CELL:Int
┃  ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃           ┃
┃  ┃           ┗━━┓ subst: .Subst
┃  ┃              ┃ constraint: true
┃  ┃              │
┃  ┃              ├─ 64 (split)
┃  ┃              │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃              │   pc: PC_CELL:Int
┃  ┃              │   callDepth: CALLDEPTH_CELL:Int
┃  ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃              ┃
┃  ┃              ┃ (branch)
┃  ┃              ┣━━┓ subst: .Subst
┃  ┃              ┃  ┃ constraint:
┃  ┃              ┃  ┃     BAL:Int <Int W0:Int
┃  ┃              ┃  │
┃  ┃              ┃  ├─ 92
┃  ┃              ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃              ┃  │   pc: PC_CELL:Int
┃  ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃              ┃  │
┃  ┃              ┃  ┊  constraint:
┃  ┃              ┃  ┊      false
┃  ┃              ┃  ┊  subst: .Subst
┃  ┃              ┃  └─ 2 (leaf, target)
┃  ┃              ┃      k: K_CELL:K
┃  ┃              ┃      pc: FINAL_PC_CELL:Int
┃  ┃              ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃              ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃              ┃
┃  ┃              ┗━━┓ subst: .Subst
┃  ┃                 ┃ constraint: true
┃  ┃                 │
┃  ┃                 ├─ 93 (split)
┃  ┃                 │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                 │   pc: PC_CELL:Int
┃  ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                 ┃
┃  ┃                 ┃ (branch)
┃  ┃                 ┣━━┓ subst: .Subst
┃  ┃                 ┃  ┃ constraint:
┃  ┃                 ┃  ┃     BAL:Int <Int W0:Int
┃  ┃                 ┃  │
┃  ┃                 ┃  ├─ 127
┃  ┃                 ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                 ┃  │   pc: PC_CELL:Int
┃  ┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                 ┃  │
┃  ┃                 ┃  ┊  constraint:
┃  ┃                 ┃  ┊      false
┃  ┃                 ┃  ┊  subst: .Subst
┃  ┃                 ┃  └─ 2 (leaf, target)
┃  ┃                 ┃      k: K_CELL:K
┃  ┃                 ┃      pc: FINAL_PC_CELL:Int
┃  ┃                 ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃                 ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃                 ┃
┃  ┃                 ┗━━┓ subst: .Subst
┃  ┃                    ┃ constraint: true
┃  ┃                    │
┃  ┃                    ├─ 128 (split)
┃  ┃                    │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                    │   pc: PC_CELL:Int
┃  ┃                    │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                    │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                    ┃
┃  ┃                    ┃ (branch)
┃  ┃                    ┣━━┓ subst: .Subst
┃  ┃                    ┃  ┃ constraint:
┃  ┃                    ┃  ┃     BAL:Int <Int W0:Int
┃  ┃                    ┃  │
┃  ┃                    ┃  ├─ 172
┃  ┃                    ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                    ┃  │   pc: PC_CELL:Int
┃  ┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                    ┃  │
┃  ┃                    ┃  ┊  constraint:
┃  ┃                    ┃  ┊      false
┃  ┃                    ┃  ┊  subst: .Subst
┃  ┃                    ┃  └─ 2 (leaf, target)
┃  ┃                    ┃      k: K_CELL:K
┃  ┃                    ┃      pc: FINAL_PC_CELL:Int
┃  ┃                    ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃                    ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃                    ┃
┃  ┃                    ┗━━┓ subst: .Subst
┃  ┃                       ┃ constraint: true
┃  ┃                       │
┃  ┃                       ├─ 173 (split)
┃  ┃                       │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                       │   pc: PC_CELL:Int
┃  ┃                       │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                       │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                       ┃
┃  ┃                       ┃ (branch)
┃  ┃                       ┣━━┓ subst: .Subst
┃  ┃                       ┃  ┃ constraint:
┃  ┃                       ┃  ┃     BAL:Int <Int W0:Int
┃  ┃                       ┃  │
┃  ┃                       ┃  ├─ 223
┃  ┃                       ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                       ┃  │   pc: PC_CELL:Int
┃  ┃                       ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                       ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                       ┃  │
┃  ┃                       ┃  ┊  constraint:
┃  ┃                       ┃  ┊      false
┃  ┃                       ┃  ┊  subst: .Subst
┃  ┃                       ┃  └─ 2 (leaf, target)
┃  ┃                       ┃      k: K_CELL:K
┃  ┃                       ┃      pc: FINAL_PC_CELL:Int
┃  ┃                       ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃                       ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃                       ┃
┃  ┃                       ┗━━┓ subst: .Subst
┃  ┃                          ┃ constraint: true
┃  ┃                          │
┃  ┃                          ├─ 224 (split)
┃  ┃                          │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                          │   pc: PC_CELL:Int
┃  ┃                          │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                          │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                          ┃
┃  ┃                          ┃ (branch)
┃  ┃                          ┣━━┓ subst: .Subst
┃  ┃                          ┃  ┃ constraint:
┃  ┃                          ┃  ┃     BAL:Int <Int W0:Int
┃  ┃                          ┃  │
┃  ┃                          ┃  ├─ 292
┃  ┃                          ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                          ┃  │   pc: PC_CELL:Int
┃  ┃                          ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                          ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                          ┃  │
┃  ┃                          ┃  ┊  constraint:
┃  ┃                          ┃  ┊      false
┃  ┃                          ┃  ┊  subst: .Subst
┃  ┃                          ┃  └─ 2 (leaf, target)
┃  ┃                          ┃      k: K_CELL:K
┃  ┃                          ┃      pc: FINAL_PC_CELL:Int
┃  ┃                          ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃                          ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃                          ┃
┃  ┃                          ┗━━┓ subst: .Subst
┃  ┃                             ┃ constraint: true
┃  ┃                             │
┃  ┃                             ├─ 293 (split)
┃  ┃                             │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                             │   pc: PC_CELL:Int
┃  ┃                             │   callDepth: CALLDEPTH_CELL:Int
┃  ┃                             │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                             ┃
┃  ┃                             ┃ (branch)
┃  ┃                             ┣━━┓ subst: .Subst
┃  ┃                             ┃  ┃ constraint:
┃  ┃                             ┃  ┃     BAL:Int <Int W0:Int
┃  ┃                             ┃  │
┃  ┃                             ┃  └─ 384 (leaf, pending)
┃  ┃                             ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                             ┃      pc: PC_CELL:Int
┃  ┃                             ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃                             ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃                             ┃
┃  ┃                             ┗━━┓ subst: .Subst
┃  ┃                                ┃ constraint: true
┃  ┃                                │
┃  ┃                                └─ 385 (leaf, pending)
┃  ┃                                    k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃                                    pc: PC_CELL:Int
┃  ┃                                    callDepth: CALLDEPTH_CELL:Int
┃  ┃                                    statusCode: STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┗━━┓ subst: .Subst
┃     ┃ constraint: true
┃     │
┃     ├─ 9 (split)
┃     │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃     │   pc: PC_CELL:Int
┃     │   callDepth: CALLDEPTH_CELL:Int
┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┃ (branch)
┃     ┣━━┓ subst: .Subst
┃     ┃  ┃ constraint:
┃     ┃  ┃     ID_CELL:Int ==Int WO:Int
┃     ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃     ┃  │
┃     ┃  ├─ 12
┃     ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃     ┃  │   pc: PC_CELL:Int
┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  │
┃     ┃  │  (3 steps)
┃     ┃  ├─ 19 (split)
┃     ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃     ┃  │   pc: PC_CELL:Int
┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┃ (branch)
┃     ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃ constraint:
┃     ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃     ┃  ┃  │
┃     ┃  ┃  ├─ 24
┃     ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃     ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  │
┃     ┃  ┃  │  (13 steps)
┃     ┃  ┃  ├─ 121
┃     ┃  ┃  │   k: K_CELL:K
┃     ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃     ┃  ┃  │
┃     ┃  ┃  ┊  constraint:
┃     ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃     ┃  ┃  ┊  subst: ...
┃     ┃  ┃  └─ 2 (leaf, target)
┃     ┃  ┃      k: K_CELL:K
┃     ┃  ┃      pc: FINAL_PC_CELL:Int
┃     ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┗━━┓ subst: .Subst
┃     ┃     ┃ constraint:
┃     ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃     ┃     │
┃     ┃     ├─ 25
┃     ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃     ┃     │   pc: PC_CELL:Int
┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     │
┃     ┃     │  (1 step)
┃     ┃     ├─ 36 (split)
┃     ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃     ┃     │   pc: PC_CELL:Int
┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃
┃     ┃     ┃ (branch)
┃     ┃     ┣━━┓ subst: .Subst
┃     ┃     ┃  ┃ constraint:
┃     ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃     ┃     ┃  │
┃     ┃     ┃  ├─ 47
┃     ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃  │
┃     ┃     ┃  │  (1 step)
┃     ┃     ┃  ├─ 66 (split)
┃     ┃     ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃  ┃
┃     ┃     ┃  ┃ (branch)
┃     ┃     ┃  ┣━━┓ subst: .Subst
┃     ┃     ┃  ┃  ┃ constraint:
┃     ┃     ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃     ┃     ┃  ┃  │
┃     ┃     ┃  ┃  ├─ 90
┃     ┃     ┃  ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃     ┃     ┃  ┃  │   pc: PC_CELL:Int
┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃  ┃  │
┃     ┃     ┃  ┃  │  (11 steps)
┃     ┃     ┃  ┃  ├─ 218
┃     ┃     ┃  ┃  │   k: K_CELL:K
┃     ┃     ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃  ┃  │   statusCode: EVMC_NONCE_EXCEEDED
┃     ┃     ┃  ┃  │
┃     ┃     ┃  ┃  ┊  constraint:
┃     ┃     ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃     ┃     ┃  ┃  ┊  subst: ...
┃     ┃     ┃  ┃  └─ 2 (leaf, target)
┃     ┃     ┃  ┃      k: K_CELL:K
┃     ┃     ┃  ┃      pc: FINAL_PC_CELL:Int
┃     ┃     ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃     ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃     ┃  ┃
┃     ┃     ┃  ┗━━┓ subst: .Subst
┃     ┃     ┃     ┃ constraint:
┃     ┃     ┃     ┃     0 <=Int NONCE_CELL:Int
┃     ┃     ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃     ┃     ┃     │
┃     ┃     ┃     ├─ 91
┃     ┃     ┃     │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃     ┃     ┃     │   pc: PC_CELL:Int
┃     ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     │
┃     ┃     ┃     │  (5 steps)
┃     ┃     ┃     ├─ 129 (split)
┃     ┃     ┃     │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃     │   pc: PC_CELL:Int
┃     ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃
┃     ┃     ┃     ┃ (branch)
┃     ┃     ┃     ┣━━┓ subst: .Subst
┃     ┃     ┃     ┃  ┃ constraint:
┃     ┃     ┃     ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃  ├─ 165
┃     ┃     ┃     ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃  │  (10 steps)
┃     ┃     ┃     ┃  ├─ 294
┃     ┃     ┃     ┃  │   k: K_CELL:K
┃     ┃     ┃     ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  │   statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃  ┊  constraint:
┃     ┃     ┃     ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃     ┃     ┃     ┃  ┊  subst: ...
┃     ┃     ┃     ┃  └─ 2 (leaf, target)
┃     ┃     ┃     ┃      k: K_CELL:K
┃     ┃     ┃     ┃      pc: FINAL_PC_CELL:Int
┃     ┃     ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃
┃     ┃     ┃     ┣━━┓ subst: .Subst
┃     ┃     ┃     ┃  ┃ constraint:
┃     ┃     ┃     ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃     ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃     ┃     ┃     ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃     ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃  ├─ 166
┃     ┃     ┃     ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃  │  (1 step)
┃     ┃     ┃     ┃  ├─ 211
┃     ┃     ┃     ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃
┃     ┃     ┃     ┃  ┃ (1 step)
┃     ┃     ┃     ┃  ┣━━┓
┃     ┃     ┃     ┃  ┃  │
┃     ┃     ┃     ┃  ┃  ├─ 269
┃     ┃     ┃     ┃  ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃     ┃     ┃     ┃  ┃  │   pc: PC_CELL:Int
┃     ┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  │
┃     ┃     ┃     ┃  ┃  │  (11 steps)
┃     ┃     ┃     ┃  ┃  ├─ 341
┃     ┃     ┃     ┃  ┃  │   k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃     ┃     ┃     ┃  ┃  │   pc: 0
┃     ┃     ┃     ┃  ┃  │   callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  ┃
┃     ┃     ┃     ┃  ┃  ┃ (1 step)
┃     ┃     ┃     ┃  ┃  ┣━━┓
┃     ┃     ┃     ┃  ┃  ┃  │
┃     ┃     ┃     ┃  ┃  ┃  └─ 437 (leaf, pending)
┃     ┃     ┃     ┃  ┃  ┃      k: #end EVMC_STACK_UNDERFLOW ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_ ...
┃     ┃     ┃     ┃  ┃  ┃      pc: 0
┃     ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  ┃
┃     ┃     ┃     ┃  ┃  ┣━━┓
┃     ┃     ┃     ┃  ┃  ┃  │
┃     ┃     ┃     ┃  ┃  ┃  └─ 438 (leaf, pending)
┃     ┃     ┃     ┃  ┃  ┃      k: #end EVMC_STACK_OVERFLOW ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_C ...
┃     ┃     ┃     ┃  ┃  ┃      pc: 0
┃     ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  ┃
┃     ┃     ┃     ┃  ┃  ┣━━┓
┃     ┃     ┃     ┃  ┃  ┃  │
┃     ┃     ┃     ┃  ┃  ┃  └─ 439 (leaf, pending)
┃     ┃     ┃     ┃  ┃  ┃      k: #addr [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃     ┃     ┃     ┃  ┃  ┃      pc: 0
┃     ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  ┃
┃     ┃     ┃     ┃  ┃  ┣━━┓
┃     ┃     ┃     ┃  ┃  ┃  │
┃     ┃     ┃     ┃  ┃  ┃  └─ 440 (leaf, pending)
┃     ┃     ┃     ┃  ┃  ┃      k: #end EVMC_SUCCESS ~> #execute ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int ...
┃     ┃     ┃     ┃  ┃  ┃      pc: 0
┃     ┃     ┃     ┃  ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  ┃
┃     ┃     ┃     ┃  ┃  ┗━━┓
┃     ┃     ┃     ┃  ┃     │
┃     ┃     ┃     ┃  ┃     └─ 441 (leaf, pending)
┃     ┃     ┃     ┃  ┃         k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃     ┃     ┃     ┃  ┃         pc: 0
┃     ┃     ┃     ┃  ┃         callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃
┃     ┃     ┃     ┃  ┣━━┓
┃     ┃     ┃     ┃  ┃  │
┃     ┃     ┃     ┃  ┃  ├─ 270
┃     ┃     ┃     ┃  ┃  │   k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃     ┃     ┃     ┃  ┃  │   pc: PC_CELL:Int
┃     ┃     ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃  ┃  │
┃     ┃     ┃     ┃  ┃  │  (8 steps)
┃     ┃     ┃     ┃  ┃  └─ 427 (leaf, pending)
┃     ┃     ┃     ┃  ┃      k: K_CELL:K
┃     ┃     ┃     ┃  ┃      pc: ( PC_CELL:Int +Int 1 )
┃     ┃     ┃     ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃  ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃     ┃     ┃     ┃  ┃
┃     ┃     ┃     ┃  ┗━━┓
┃     ┃     ┃     ┃     │
┃     ┃     ┃     ┃     ├─ 271
┃     ┃     ┃     ┃     │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃     ┃     │   pc: PC_CELL:Int
┃     ┃     ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃     ┃
┃     ┃     ┃     ┃     ┃ (1 step)
┃     ┃     ┃     ┃     ┣━━┓
┃     ┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃     ┃  ├─ 343
┃     ┃     ┃     ┃     ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃     ┃     ┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃     ┃  │  (11 steps)
┃     ┃     ┃     ┃     ┃  └─ 444 (leaf, pending)
┃     ┃     ┃     ┃     ┃      k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃     ┃     ┃     ┃     ┃      pc: 0
┃     ┃     ┃     ┃     ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃     ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃     ┃
┃     ┃     ┃     ┃     ┣━━┓
┃     ┃     ┃     ┃     ┃  │
┃     ┃     ┃     ┃     ┃  └─ 344 (leaf, pending)
┃     ┃     ┃     ┃     ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃     ┃     ┃     ┃     ┃      pc: PC_CELL:Int
┃     ┃     ┃     ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃     ┃
┃     ┃     ┃     ┃     ┗━━┓
┃     ┃     ┃     ┃        │
┃     ┃     ┃     ┃        ├─ 345
┃     ┃     ┃     ┃        │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃     ┃        │   pc: PC_CELL:Int
┃     ┃     ┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃        ┃
┃     ┃     ┃     ┃        ┃ (1 step)
┃     ┃     ┃     ┃        ┣━━┓
┃     ┃     ┃     ┃        ┃  │
┃     ┃     ┃     ┃        ┃  └─ 445 (leaf, pending)
┃     ┃     ┃     ┃        ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃     ┃     ┃     ┃        ┃      pc: PC_CELL:Int
┃     ┃     ┃     ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃        ┃
┃     ┃     ┃     ┃        ┣━━┓
┃     ┃     ┃     ┃        ┃  │
┃     ┃     ┃     ┃        ┃  └─ 446 (leaf, pending)
┃     ┃     ┃     ┃        ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃     ┃     ┃     ┃        ┃      pc: PC_CELL:Int
┃     ┃     ┃     ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃        ┃
┃     ┃     ┃     ┃        ┗━━┓
┃     ┃     ┃     ┃           │
┃     ┃     ┃     ┃           └─ 447 (leaf, pending)
┃     ┃     ┃     ┃               k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃     ┃               pc: PC_CELL:Int
┃     ┃     ┃     ┃               callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃     ┃               statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃     ┃
┃     ┃     ┃     ┗━━┓ subst: .Subst
┃     ┃     ┃        ┃ constraint: true
┃     ┃     ┃        │
┃     ┃     ┃        ├─ 167 (split)
┃     ┃     ┃        │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃        │   pc: PC_CELL:Int
┃     ┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃
┃     ┃     ┃        ┃ (branch)
┃     ┃     ┃        ┣━━┓ subst: .Subst
┃     ┃     ┃        ┃  ┃ constraint:
┃     ┃     ┃        ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃     ┃     ┃        ┃  │
┃     ┃     ┃        ┃  ├─ 212
┃     ┃     ┃        ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃        ┃  │   pc: PC_CELL:Int
┃     ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃  │
┃     ┃     ┃        ┃  │  (10 steps)
┃     ┃     ┃        ┃  ├─ 348
┃     ┃     ┃        ┃  │   k: K_CELL:K
┃     ┃     ┃        ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃     ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃  │   statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃     ┃     ┃        ┃  │
┃     ┃     ┃        ┃  ┊  constraint:
┃     ┃     ┃        ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃     ┃     ┃        ┃  ┊  subst: ...
┃     ┃     ┃        ┃  └─ 2 (leaf, target)
┃     ┃     ┃        ┃      k: K_CELL:K
┃     ┃     ┃        ┃      pc: FINAL_PC_CELL:Int
┃     ┃     ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃
┃     ┃     ┃        ┣━━┓ subst: .Subst
┃     ┃     ┃        ┃  ┃ constraint:
┃     ┃     ┃        ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃        ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃     ┃     ┃        ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃        ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃     ┃     ┃        ┃  │
┃     ┃     ┃        ┃  ├─ 213
┃     ┃     ┃        ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃        ┃  │   pc: PC_CELL:Int
┃     ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃  │
┃     ┃     ┃        ┃  │  (1 step)
┃     ┃     ┃        ┃  ├─ 276
┃     ┃     ┃        ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃        ┃  │   pc: PC_CELL:Int
┃     ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃  ┃
┃     ┃     ┃        ┃  ┃ (1 step)
┃     ┃     ┃        ┃  ┣━━┓
┃     ┃     ┃        ┃  ┃  │
┃     ┃     ┃        ┃  ┃  ├─ 351
┃     ┃     ┃        ┃  ┃  │   k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃     ┃     ┃        ┃  ┃  │   pc: PC_CELL:Int
┃     ┃     ┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃  ┃  │
┃     ┃     ┃        ┃  ┃  │  (11 steps)
┃     ┃     ┃        ┃  ┃  └─ 469 (leaf, pending)
┃     ┃     ┃        ┃  ┃      k: #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , S ...
┃     ┃     ┃        ┃  ┃      pc: 0
┃     ┃     ┃        ┃  ┃      callDepth: ( CALLDEPTH_CELL:Int +Int 1 )
┃     ┃     ┃        ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃  ┃
┃     ┃     ┃        ┃  ┣━━┓
┃     ┃     ┃        ┃  ┃  │
┃     ┃     ┃        ┃  ┃  └─ 352 (leaf, pending)
┃     ┃     ┃        ┃  ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃     ┃     ┃        ┃  ┃      pc: PC_CELL:Int
┃     ┃     ┃        ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃  ┃
┃     ┃     ┃        ┃  ┗━━┓
┃     ┃     ┃        ┃     │
┃     ┃     ┃        ┃     ├─ 353
┃     ┃     ┃        ┃     │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃        ┃     │   pc: PC_CELL:Int
┃     ┃     ┃        ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃     ┃
┃     ┃     ┃        ┃     ┃ (1 step)
┃     ┃     ┃        ┃     ┣━━┓
┃     ┃     ┃        ┃     ┃  │
┃     ┃     ┃        ┃     ┃  └─ 457 (leaf, pending)
┃     ┃     ┃        ┃     ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃     ┃     ┃        ┃     ┃      pc: PC_CELL:Int
┃     ┃     ┃        ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃     ┃
┃     ┃     ┃        ┃     ┣━━┓
┃     ┃     ┃        ┃     ┃  │
┃     ┃     ┃        ┃     ┃  └─ 458 (leaf, pending)
┃     ┃     ┃        ┃     ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃     ┃     ┃        ┃     ┃      pc: PC_CELL:Int
┃     ┃     ┃        ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃     ┃
┃     ┃     ┃        ┃     ┗━━┓
┃     ┃     ┃        ┃        │
┃     ┃     ┃        ┃        └─ 459 (leaf, pending)
┃     ┃     ┃        ┃            k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃        ┃            pc: PC_CELL:Int
┃     ┃     ┃        ┃            callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃        ┃            statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃        ┃
┃     ┃     ┃        ┗━━┓ subst: .Subst
┃     ┃     ┃           ┃ constraint: true
┃     ┃     ┃           │
┃     ┃     ┃           ├─ 214 (split)
┃     ┃     ┃           │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃           │   pc: PC_CELL:Int
┃     ┃     ┃           │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃
┃     ┃     ┃           ┃ (branch)
┃     ┃     ┃           ┣━━┓ subst: .Subst
┃     ┃     ┃           ┃  ┃ constraint:
┃     ┃     ┃           ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃     ┃     ┃           ┃  │
┃     ┃     ┃           ┃  ├─ 277
┃     ┃     ┃           ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃           ┃  │   pc: PC_CELL:Int
┃     ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃  │
┃     ┃     ┃           ┃  │  (10 steps)
┃     ┃     ┃           ┃  └─ 424 (leaf, pending)
┃     ┃     ┃           ┃      k: K_CELL:K
┃     ┃     ┃           ┃      pc: ( PC_CELL:Int +Int 1 )
┃     ┃     ┃           ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃     ┃     ┃           ┃
┃     ┃     ┃           ┣━━┓ subst: .Subst
┃     ┃     ┃           ┃  ┃ constraint:
┃     ┃     ┃           ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃           ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃     ┃     ┃           ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃           ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃     ┃     ┃           ┃  │
┃     ┃     ┃           ┃  ├─ 278
┃     ┃     ┃           ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃           ┃  │   pc: PC_CELL:Int
┃     ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃  │
┃     ┃     ┃           ┃  │  (1 step)
┃     ┃     ┃           ┃  ├─ 357
┃     ┃     ┃           ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃           ┃  │   pc: PC_CELL:Int
┃     ┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃  ┃
┃     ┃     ┃           ┃  ┃ (1 step)
┃     ┃     ┃           ┃  ┣━━┓
┃     ┃     ┃           ┃  ┃  │
┃     ┃     ┃           ┃  ┃  └─ 463 (leaf, pending)
┃     ┃     ┃           ┃  ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃     ┃     ┃           ┃  ┃      pc: PC_CELL:Int
┃     ┃     ┃           ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃  ┃
┃     ┃     ┃           ┃  ┣━━┓
┃     ┃     ┃           ┃  ┃  │
┃     ┃     ┃           ┃  ┃  └─ 464 (leaf, pending)
┃     ┃     ┃           ┃  ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃     ┃     ┃           ┃  ┃      pc: PC_CELL:Int
┃     ┃     ┃           ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃  ┃
┃     ┃     ┃           ┃  ┗━━┓
┃     ┃     ┃           ┃     │
┃     ┃     ┃           ┃     └─ 465 (leaf, pending)
┃     ┃     ┃           ┃         k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃           ┃         pc: PC_CELL:Int
┃     ┃     ┃           ┃         callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃           ┃         statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃           ┃
┃     ┃     ┃           ┗━━┓ subst: .Subst
┃     ┃     ┃              ┃ constraint: true
┃     ┃     ┃              │
┃     ┃     ┃              ├─ 279 (split)
┃     ┃     ┃              │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃              │   pc: PC_CELL:Int
┃     ┃     ┃              │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃              ┃
┃     ┃     ┃              ┃ (branch)
┃     ┃     ┃              ┣━━┓ subst: .Subst
┃     ┃     ┃              ┃  ┃ constraint:
┃     ┃     ┃              ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃     ┃     ┃              ┃  │
┃     ┃     ┃              ┃  └─ 359 (leaf, pending)
┃     ┃     ┃              ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃              ┃      pc: PC_CELL:Int
┃     ┃     ┃              ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃              ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃              ┃
┃     ┃     ┃              ┣━━┓ subst: .Subst
┃     ┃     ┃              ┃  ┃ constraint:
┃     ┃     ┃              ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃              ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃     ┃     ┃              ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃              ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃     ┃     ┃              ┃  │
┃     ┃     ┃              ┃  ├─ 360
┃     ┃     ┃              ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃              ┃  │   pc: PC_CELL:Int
┃     ┃     ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃              ┃  │
┃     ┃     ┃              ┃  │  (1 step)
┃     ┃     ┃              ┃  └─ 470 (leaf, pending)
┃     ┃     ┃              ┃      k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃     ┃     ┃              ┃      pc: PC_CELL:Int
┃     ┃     ┃              ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃              ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃              ┃
┃     ┃     ┃              ┗━━┓ subst: .Subst
┃     ┃     ┃                 ┃ constraint: true
┃     ┃     ┃                 │
┃     ┃     ┃                 ├─ 361 (split)
┃     ┃     ┃                 │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃                 │   pc: PC_CELL:Int
┃     ┃     ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃                 ┃
┃     ┃     ┃                 ┃ (branch)
┃     ┃     ┃                 ┣━━┓ subst: .Subst
┃     ┃     ┃                 ┃  ┃ constraint:
┃     ┃     ┃                 ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃     ┃     ┃                 ┃  │
┃     ┃     ┃                 ┃  └─ 471 (leaf, pending)
┃     ┃     ┃                 ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃                 ┃      pc: PC_CELL:Int
┃     ┃     ┃                 ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃                 ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃                 ┃
┃     ┃     ┃                 ┣━━┓ subst: .Subst
┃     ┃     ┃                 ┃  ┃ constraint:
┃     ┃     ┃                 ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃                 ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃     ┃     ┃                 ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃     ┃                 ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃     ┃     ┃                 ┃  │
┃     ┃     ┃                 ┃  └─ 472 (leaf, pending)
┃     ┃     ┃                 ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃                 ┃      pc: PC_CELL:Int
┃     ┃     ┃                 ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃                 ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃                 ┃
┃     ┃     ┃                 ┗━━┓ subst: .Subst
┃     ┃     ┃                    ┃ constraint: true
┃     ┃     ┃                    │
┃     ┃     ┃                    └─ 473 (leaf, pending)
┃     ┃     ┃                        k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃     ┃     ┃                        pc: PC_CELL:Int
┃     ┃     ┃                        callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃                        statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃
┃     ┃     ┗━━┓ subst: .Subst
┃     ┃        ┃ constraint:
┃     ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃     ┃        │
┃     ┃        ├─ 48
┃     ┃        │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃     ┃        │   pc: PC_CELL:Int
┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃        │
┃     ┃        │  (12 steps)
┃     ┃        ├─ 123
┃     ┃        │   k: K_CELL:K
┃     ┃        │   pc: ( PC_CELL:Int +Int 1 )
┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃     ┃        │   statusCode: EVMC_CALL_DEPTH_EXCEEDED
┃     ┃        │
┃     ┃        ┊  constraint:
┃     ┃        ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃     ┃        ┊  subst: ...
┃     ┃        └─ 2 (leaf, target)
┃     ┃            k: K_CELL:K
┃     ┃            pc: FINAL_PC_CELL:Int
┃     ┃            callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃            statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┣━━┓ subst: .Subst
┃     ┃  ┃ constraint:
┃     ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃     ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃     ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃     ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃     ┃  │
┃     ┃  ├─ 13
┃     ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃     ┃  │   pc: PC_CELL:Int
┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  │
┃     ┃  │  (3 steps)
┃     ┃  ├─ 21 (split)
┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  │   pc: PC_CELL:Int
┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┃ (branch)
┃     ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃ constraint:
┃     ┃  ┃  ┃     BAL:Int <Int W0:Int
┃     ┃  ┃  │
┃     ┃  ┃  ├─ 33 (split)
┃     ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃
┃     ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ├─ 52 (split)
┃     ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ├─ 73 (split)
┃     ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ┃  ├─ 99 (split)
┃     ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ├─ 137 (split)
┃     ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 179 (split)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 232 (split)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 301 (split)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  └─ 393 (leaf, pending)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 394 (leaf, pending)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 302
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 233
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃     ├─ 180
┃     ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃     ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃     ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃     ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃     ├─ 138
┃     ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃     ┃  ┃  ┃  ┃  ┃     ┊      false
┃     ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃     ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃     ├─ 100
┃     ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃     │
┃     ┃  ┃  ┃  ┃     ┊  constraint:
┃     ┃  ┃  ┃  ┃     ┊      false
┃     ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃  ┃  ┃         k: K_CELL:K
┃     ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  ┃
┃     ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃  ┃     ┃ constraint:
┃     ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃  ┃     │
┃     ┃  ┃  ┃     ├─ 74
┃     ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃     │
┃     ┃  ┃  ┃     ┊  constraint:
┃     ┃  ┃  ┃     ┊      false
┃     ┃  ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃  ┃         k: K_CELL:K
┃     ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃
┃     ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃     ┃ constraint:
┃     ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃  ┃     │
┃     ┃  ┃     ├─ 53
┃     ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  ┃     │   pc: PC_CELL:Int
┃     ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃     │
┃     ┃  ┃     ┊  constraint:
┃     ┃  ┃     ┊      false
┃     ┃  ┃     ┊  subst: .Subst
┃     ┃  ┃     └─ 2 (leaf, target)
┃     ┃  ┃         k: K_CELL:K
┃     ┃  ┃         pc: FINAL_PC_CELL:Int
┃     ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┗━━┓ subst: .Subst
┃     ┃     ┃ constraint:
┃     ┃     ┃     W0:Int <=Int BAL:Int
┃     ┃     │
┃     ┃     ├─ 34 (split)
┃     ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃     │   pc: PC_CELL:Int
┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃
┃     ┃     ┃ (branch)
┃     ┃     ┣━━┓ subst: .Subst
┃     ┃     ┃  ┃ constraint:
┃     ┃     ┃  ┃     BAL:Int <Int W0:Int
┃     ┃     ┃  │
┃     ┃     ┃  ├─ 54
┃     ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃     ┃  │   pc: PC_CELL:Int
┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     ┃  │
┃     ┃     ┃  ┊  constraint:
┃     ┃     ┃  ┊      false
┃     ┃     ┃  ┊  subst: .Subst
┃     ┃     ┃  └─ 2 (leaf, target)
┃     ┃     ┃      k: K_CELL:K
┃     ┃     ┃      pc: FINAL_PC_CELL:Int
┃     ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃     ┃
┃     ┃     ┗━━┓ subst: .Subst
┃     ┃        ┃ constraint: true
┃     ┃        │
┃     ┃        ├─ 55 (split)
┃     ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃        │   pc: PC_CELL:Int
┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃        ┃
┃     ┃        ┃ (branch)
┃     ┃        ┣━━┓ subst: .Subst
┃     ┃        ┃  ┃ constraint:
┃     ┃        ┃  ┃     BAL:Int <Int W0:Int
┃     ┃        ┃  │
┃     ┃        ┃  ├─ 79
┃     ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃        ┃  │   pc: PC_CELL:Int
┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃        ┃  │
┃     ┃        ┃  ┊  constraint:
┃     ┃        ┃  ┊      false
┃     ┃        ┃  ┊  subst: .Subst
┃     ┃        ┃  └─ 2 (leaf, target)
┃     ┃        ┃      k: K_CELL:K
┃     ┃        ┃      pc: FINAL_PC_CELL:Int
┃     ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃        ┃
┃     ┃        ┗━━┓ subst: .Subst
┃     ┃           ┃ constraint: true
┃     ┃           │
┃     ┃           ├─ 80 (split)
┃     ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃           │   pc: PC_CELL:Int
┃     ┃           │   callDepth: CALLDEPTH_CELL:Int
┃     ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃           ┃
┃     ┃           ┃ (branch)
┃     ┃           ┣━━┓ subst: .Subst
┃     ┃           ┃  ┃ constraint:
┃     ┃           ┃  ┃     BAL:Int <Int W0:Int
┃     ┃           ┃  │
┃     ┃           ┃  ├─ 106
┃     ┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃           ┃  │   pc: PC_CELL:Int
┃     ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃           ┃  │
┃     ┃           ┃  ┊  constraint:
┃     ┃           ┃  ┊      false
┃     ┃           ┃  ┊  subst: .Subst
┃     ┃           ┃  └─ 2 (leaf, target)
┃     ┃           ┃      k: K_CELL:K
┃     ┃           ┃      pc: FINAL_PC_CELL:Int
┃     ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃           ┃
┃     ┃           ┗━━┓ subst: .Subst
┃     ┃              ┃ constraint: true
┃     ┃              │
┃     ┃              ├─ 107 (split)
┃     ┃              │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃              │   pc: PC_CELL:Int
┃     ┃              │   callDepth: CALLDEPTH_CELL:Int
┃     ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃              ┃
┃     ┃              ┃ (branch)
┃     ┃              ┣━━┓ subst: .Subst
┃     ┃              ┃  ┃ constraint:
┃     ┃              ┃  ┃     BAL:Int <Int W0:Int
┃     ┃              ┃  │
┃     ┃              ┃  ├─ 143
┃     ┃              ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃              ┃  │   pc: PC_CELL:Int
┃     ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃              ┃  │
┃     ┃              ┃  ┊  constraint:
┃     ┃              ┃  ┊      false
┃     ┃              ┃  ┊  subst: .Subst
┃     ┃              ┃  └─ 2 (leaf, target)
┃     ┃              ┃      k: K_CELL:K
┃     ┃              ┃      pc: FINAL_PC_CELL:Int
┃     ┃              ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃              ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃              ┃
┃     ┃              ┗━━┓ subst: .Subst
┃     ┃                 ┃ constraint: true
┃     ┃                 │
┃     ┃                 ├─ 144 (split)
┃     ┃                 │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                 │   pc: PC_CELL:Int
┃     ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                 ┃
┃     ┃                 ┃ (branch)
┃     ┃                 ┣━━┓ subst: .Subst
┃     ┃                 ┃  ┃ constraint:
┃     ┃                 ┃  ┃     BAL:Int <Int W0:Int
┃     ┃                 ┃  │
┃     ┃                 ┃  ├─ 185
┃     ┃                 ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                 ┃  │   pc: PC_CELL:Int
┃     ┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                 ┃  │
┃     ┃                 ┃  ┊  constraint:
┃     ┃                 ┃  ┊      false
┃     ┃                 ┃  ┊  subst: .Subst
┃     ┃                 ┃  └─ 2 (leaf, target)
┃     ┃                 ┃      k: K_CELL:K
┃     ┃                 ┃      pc: FINAL_PC_CELL:Int
┃     ┃                 ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃                 ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃                 ┃
┃     ┃                 ┗━━┓ subst: .Subst
┃     ┃                    ┃ constraint: true
┃     ┃                    │
┃     ┃                    ├─ 186 (split)
┃     ┃                    │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                    │   pc: PC_CELL:Int
┃     ┃                    │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                    │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                    ┃
┃     ┃                    ┃ (branch)
┃     ┃                    ┣━━┓ subst: .Subst
┃     ┃                    ┃  ┃ constraint:
┃     ┃                    ┃  ┃     BAL:Int <Int W0:Int
┃     ┃                    ┃  │
┃     ┃                    ┃  ├─ 238
┃     ┃                    ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                    ┃  │   pc: PC_CELL:Int
┃     ┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                    ┃  │
┃     ┃                    ┃  ┊  constraint:
┃     ┃                    ┃  ┊      false
┃     ┃                    ┃  ┊  subst: .Subst
┃     ┃                    ┃  └─ 2 (leaf, target)
┃     ┃                    ┃      k: K_CELL:K
┃     ┃                    ┃      pc: FINAL_PC_CELL:Int
┃     ┃                    ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃                    ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃                    ┃
┃     ┃                    ┗━━┓ subst: .Subst
┃     ┃                       ┃ constraint: true
┃     ┃                       │
┃     ┃                       ├─ 239 (split)
┃     ┃                       │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                       │   pc: PC_CELL:Int
┃     ┃                       │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                       │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                       ┃
┃     ┃                       ┃ (branch)
┃     ┃                       ┣━━┓ subst: .Subst
┃     ┃                       ┃  ┃ constraint:
┃     ┃                       ┃  ┃     BAL:Int <Int W0:Int
┃     ┃                       ┃  │
┃     ┃                       ┃  ├─ 307
┃     ┃                       ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                       ┃  │   pc: PC_CELL:Int
┃     ┃                       ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                       ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                       ┃  │
┃     ┃                       ┃  ┊  constraint:
┃     ┃                       ┃  ┊      false
┃     ┃                       ┃  ┊  subst: .Subst
┃     ┃                       ┃  └─ 2 (leaf, target)
┃     ┃                       ┃      k: K_CELL:K
┃     ┃                       ┃      pc: FINAL_PC_CELL:Int
┃     ┃                       ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃                       ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃                       ┃
┃     ┃                       ┗━━┓ subst: .Subst
┃     ┃                          ┃ constraint: true
┃     ┃                          │
┃     ┃                          ├─ 308 (split)
┃     ┃                          │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                          │   pc: PC_CELL:Int
┃     ┃                          │   callDepth: CALLDEPTH_CELL:Int
┃     ┃                          │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                          ┃
┃     ┃                          ┃ (branch)
┃     ┃                          ┣━━┓ subst: .Subst
┃     ┃                          ┃  ┃ constraint:
┃     ┃                          ┃  ┃     BAL:Int <Int W0:Int
┃     ┃                          ┃  │
┃     ┃                          ┃  └─ 400 (leaf, pending)
┃     ┃                          ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                          ┃      pc: PC_CELL:Int
┃     ┃                          ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃                          ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃                          ┃
┃     ┃                          ┗━━┓ subst: .Subst
┃     ┃                             ┃ constraint: true
┃     ┃                             │
┃     ┃                             └─ 401 (leaf, pending)
┃     ┃                                 k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃                                 pc: PC_CELL:Int
┃     ┃                                 callDepth: CALLDEPTH_CELL:Int
┃     ┃                                 statusCode: STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┗━━┓ subst: .Subst
┃        ┃ constraint: true
┃        │
┃        ├─ 14 (split)
┃        │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃        │   pc: PC_CELL:Int
┃        │   callDepth: CALLDEPTH_CELL:Int
┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┃ (branch)
┃        ┣━━┓ subst: .Subst
┃        ┃  ┃ constraint:
┃        ┃  ┃     ID_CELL:Int ==Int WO:Int
┃        ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃        ┃  │
┃        ┃  ├─ 26
┃        ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  │
┃        ┃  │  (3 steps)
┃        ┃  ├─ 35 (split)
┃        ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┃ (branch)
┃        ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃ constraint:
┃        ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃        ┃  ┃  │
┃        ┃  ┃  ├─ 45
┃        ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃        ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  │
┃        ┃  ┃  │  (13 steps)
┃        ┃  ┃  ├─ 130
┃        ┃  ┃  │   k: K_CELL:K
┃        ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃        ┃  ┃  │
┃        ┃  ┃  ┊  constraint:
┃        ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃        ┃  ┃  ┊  subst: ...
┃        ┃  ┃  └─ 2 (leaf, target)
┃        ┃  ┃      k: K_CELL:K
┃        ┃  ┃      pc: FINAL_PC_CELL:Int
┃        ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┗━━┓ subst: .Subst
┃        ┃     ┃ constraint:
┃        ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃        ┃     │
┃        ┃     ├─ 46
┃        ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃        ┃     │   pc: PC_CELL:Int
┃        ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     │
┃        ┃     │  (1 step)
┃        ┃     ├─ 65 (split)
┃        ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃        ┃     │   pc: PC_CELL:Int
┃        ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃
┃        ┃     ┃ (branch)
┃        ┃     ┣━━┓ subst: .Subst
┃        ┃     ┃  ┃ constraint:
┃        ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃        ┃     ┃  │
┃        ┃     ┃  ├─ 88
┃        ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃        ┃     ┃  │   pc: PC_CELL:Int
┃        ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃  │
┃        ┃     ┃  │  (1 step)
┃        ┃     ┃  ├─ 119 (split)
┃        ┃     ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃        ┃     ┃  │   pc: PC_CELL:Int
┃        ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃  ┃
┃        ┃     ┃  ┃ (branch)
┃        ┃     ┃  ┣━━┓ subst: .Subst
┃        ┃     ┃  ┃  ┃ constraint:
┃        ┃     ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃        ┃     ┃  ┃  │
┃        ┃     ┃  ┃  ├─ 157
┃        ┃     ┃  ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃        ┃     ┃  ┃  │   pc: PC_CELL:Int
┃        ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃  ┃  │
┃        ┃     ┃  ┃  │  (11 steps)
┃        ┃     ┃  ┃  ├─ 265
┃        ┃     ┃  ┃  │   k: K_CELL:K
┃        ┃     ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃        ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃  ┃  │   statusCode: EVMC_NONCE_EXCEEDED
┃        ┃     ┃  ┃  │
┃        ┃     ┃  ┃  ┊  constraint:
┃        ┃     ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃        ┃     ┃  ┃  ┊  subst: ...
┃        ┃     ┃  ┃  └─ 2 (leaf, target)
┃        ┃     ┃  ┃      k: K_CELL:K
┃        ┃     ┃  ┃      pc: FINAL_PC_CELL:Int
┃        ┃     ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃     ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃     ┃  ┃
┃        ┃     ┃  ┗━━┓ subst: .Subst
┃        ┃     ┃     ┃ constraint:
┃        ┃     ┃     ┃     0 <=Int NONCE_CELL:Int
┃        ┃     ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃        ┃     ┃     │
┃        ┃     ┃     ├─ 158
┃        ┃     ┃     │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃        ┃     ┃     │   pc: PC_CELL:Int
┃        ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     │
┃        ┃     ┃     │  (5 steps)
┃        ┃     ┃     ├─ 200 (split)
┃        ┃     ┃     │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃     │   pc: PC_CELL:Int
┃        ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃
┃        ┃     ┃     ┃ (branch)
┃        ┃     ┃     ┣━━┓ subst: .Subst
┃        ┃     ┃     ┃  ┃ constraint:
┃        ┃     ┃     ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃        ┃     ┃     ┃  │
┃        ┃     ┃     ┃  ├─ 252
┃        ┃     ┃     ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃     ┃  │   pc: PC_CELL:Int
┃        ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃  │
┃        ┃     ┃     ┃  │  (10 steps)
┃        ┃     ┃     ┃  └─ 395 (leaf, pending)
┃        ┃     ┃     ┃      k: K_CELL:K
┃        ┃     ┃     ┃      pc: ( PC_CELL:Int +Int 1 )
┃        ┃     ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃        ┃     ┃     ┃
┃        ┃     ┃     ┣━━┓ subst: .Subst
┃        ┃     ┃     ┃  ┃ constraint:
┃        ┃     ┃     ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃     ┃     ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃        ┃     ┃     ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃     ┃     ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃        ┃     ┃     ┃  │
┃        ┃     ┃     ┃  ├─ 253
┃        ┃     ┃     ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃     ┃  │   pc: PC_CELL:Int
┃        ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃  │
┃        ┃     ┃     ┃  │  (1 step)
┃        ┃     ┃     ┃  ├─ 321
┃        ┃     ┃     ┃  │   k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃        ┃     ┃     ┃  │   pc: PC_CELL:Int
┃        ┃     ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃  ┃
┃        ┃     ┃     ┃  ┃ (1 step)
┃        ┃     ┃     ┃  ┣━━┓
┃        ┃     ┃     ┃  ┃  │
┃        ┃     ┃     ┃  ┃  └─ 413 (leaf, pending)
┃        ┃     ┃     ┃  ┃      k: #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int ~> #mkCreate W ...
┃        ┃     ┃     ┃  ┃      pc: PC_CELL:Int
┃        ┃     ┃     ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃  ┃
┃        ┃     ┃     ┃  ┣━━┓
┃        ┃     ┃     ┃  ┃  │
┃        ┃     ┃     ┃  ┃  └─ 414 (leaf, pending)
┃        ┃     ┃     ┃  ┃      k: #end EVMC_ACCOUNT_ALREADY_EXISTS ~> #transferFunds WO:Int #newAddr ( WO:Int , NO ...
┃        ┃     ┃     ┃  ┃      pc: PC_CELL:Int
┃        ┃     ┃     ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃  ┃
┃        ┃     ┃     ┃  ┗━━┓
┃        ┃     ┃     ┃     │
┃        ┃     ┃     ┃     └─ 415 (leaf, pending)
┃        ┃     ┃     ┃         k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃        ┃     ┃     ┃         pc: PC_CELL:Int
┃        ┃     ┃     ┃         callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃     ┃         statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃     ┃
┃        ┃     ┃     ┗━━┓ subst: .Subst
┃        ┃     ┃        ┃ constraint: true
┃        ┃     ┃        │
┃        ┃     ┃        ├─ 254 (split)
┃        ┃     ┃        │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃        │   pc: PC_CELL:Int
┃        ┃     ┃        │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃        ┃
┃        ┃     ┃        ┃ (branch)
┃        ┃     ┃        ┣━━┓ subst: .Subst
┃        ┃     ┃        ┃  ┃ constraint:
┃        ┃     ┃        ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃        ┃     ┃        ┃  │
┃        ┃     ┃        ┃  ├─ 322
┃        ┃     ┃        ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃        ┃  │   pc: PC_CELL:Int
┃        ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃        ┃  │
┃        ┃     ┃        ┃  │  (10 steps)
┃        ┃     ┃        ┃  └─ 483 (leaf, pending)
┃        ┃     ┃        ┃      k: K_CELL:K
┃        ┃     ┃        ┃      pc: ( PC_CELL:Int +Int 1 )
┃        ┃     ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃        ┃      statusCode: EVMC_ACCOUNT_ALREADY_EXISTS
┃        ┃     ┃        ┃
┃        ┃     ┃        ┣━━┓ subst: .Subst
┃        ┃     ┃        ┃  ┃ constraint:
┃        ┃     ┃        ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃     ┃        ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃        ┃     ┃        ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃     ┃        ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃        ┃     ┃        ┃  │
┃        ┃     ┃        ┃  ├─ 323
┃        ┃     ┃        ┃  │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃        ┃  │   pc: PC_CELL:Int
┃        ┃     ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃        ┃  │
┃        ┃     ┃        ┃  │  (1 step)
┃        ┃     ┃        ┃  └─ 417 (leaf, pending)
┃        ┃     ┃        ┃      k: #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:In ...
┃        ┃     ┃        ┃      pc: PC_CELL:Int
┃        ┃     ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃        ┃
┃        ┃     ┃        ┗━━┓ subst: .Subst
┃        ┃     ┃           ┃ constraint: true
┃        ┃     ┃           │
┃        ┃     ┃           ├─ 324 (split)
┃        ┃     ┃           │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃           │   pc: PC_CELL:Int
┃        ┃     ┃           │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃           ┃
┃        ┃     ┃           ┃ (branch)
┃        ┃     ┃           ┣━━┓ subst: .Subst
┃        ┃     ┃           ┃  ┃ constraint:
┃        ┃     ┃           ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃        ┃     ┃           ┃  │
┃        ┃     ┃           ┃  └─ 418 (leaf, pending)
┃        ┃     ┃           ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃           ┃      pc: PC_CELL:Int
┃        ┃     ┃           ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃           ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃           ┃
┃        ┃     ┃           ┣━━┓ subst: .Subst
┃        ┃     ┃           ┃  ┃ constraint:
┃        ┃     ┃           ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃     ┃           ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃        ┃     ┃           ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃     ┃           ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃        ┃     ┃           ┃  │
┃        ┃     ┃           ┃  └─ 419 (leaf, pending)
┃        ┃     ┃           ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃           ┃      pc: PC_CELL:Int
┃        ┃     ┃           ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃           ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃           ┃
┃        ┃     ┃           ┗━━┓ subst: .Subst
┃        ┃     ┃              ┃ constraint: true
┃        ┃     ┃              │
┃        ┃     ┃              └─ 420 (leaf, pending)
┃        ┃     ┃                  k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃        ┃     ┃                  pc: PC_CELL:Int
┃        ┃     ┃                  callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃                  statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃
┃        ┃     ┗━━┓ subst: .Subst
┃        ┃        ┃ constraint:
┃        ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃        ┃        │
┃        ┃        ├─ 89
┃        ┃        │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃        ┃        │   pc: PC_CELL:Int
┃        ┃        │   callDepth: CALLDEPTH_CELL:Int
┃        ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃        │
┃        ┃        │  (12 steps)
┃        ┃        ├─ 203
┃        ┃        │   k: K_CELL:K
┃        ┃        │   pc: ( PC_CELL:Int +Int 1 )
┃        ┃        │   callDepth: CALLDEPTH_CELL:Int
┃        ┃        │   statusCode: EVMC_CALL_DEPTH_EXCEEDED
┃        ┃        │
┃        ┃        ┊  constraint:
┃        ┃        ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃        ┃        ┊  subst: ...
┃        ┃        └─ 2 (leaf, target)
┃        ┃            k: K_CELL:K
┃        ┃            pc: FINAL_PC_CELL:Int
┃        ┃            callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃            statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┣━━┓ subst: .Subst
┃        ┃  ┃ constraint:
┃        ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃        ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃        ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃        ┃  │
┃        ┃  ├─ 27
┃        ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  │
┃        ┃  │  (3 steps)
┃        ┃  ├─ 39 (split)
┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┃ (branch)
┃        ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃ constraint:
┃        ┃  ┃  ┃     BAL:Int <Int W0:Int
┃        ┃  ┃  │
┃        ┃  ┃  ├─ 49 (split)
┃        ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃
┃        ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ├─ 69 (split)
┃        ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ┃  ├─ 95 (split)
┃        ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ┃  ┃  ├─ 133 (split)
┃        ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ├─ 175 (split)
┃        ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 227 (split)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 296 (split)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  └─ 389 (leaf, pending)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 390 (leaf, pending)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     ├─ 297
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃        ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃  ┃     ├─ 228
┃        ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃        ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃        ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃        ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃        ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃        ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃     ├─ 176
┃        ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃        ┃  ┃  ┃  ┃  ┃     ┊      false
┃        ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃        ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃        ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃        ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃     ┃ constraint:
┃        ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃     ├─ 134
┃        ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃     │
┃        ┃  ┃  ┃  ┃     ┊  constraint:
┃        ┃  ┃  ┃  ┃     ┊      false
┃        ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃        ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃        ┃  ┃  ┃  ┃         k: K_CELL:K
┃        ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃        ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  ┃
┃        ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃  ┃     ┃ constraint:
┃        ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃  ┃     │
┃        ┃  ┃  ┃     ├─ 96
┃        ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃  ┃     │   pc: PC_CELL:Int
┃        ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃     │
┃        ┃  ┃  ┃     ┊  constraint:
┃        ┃  ┃  ┃     ┊      false
┃        ┃  ┃  ┃     ┊  subst: .Subst
┃        ┃  ┃  ┃     └─ 2 (leaf, target)
┃        ┃  ┃  ┃         k: K_CELL:K
┃        ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃        ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃
┃        ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃     ┃ constraint:
┃        ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃  ┃     │
┃        ┃  ┃     ├─ 70
┃        ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  ┃     │   pc: PC_CELL:Int
┃        ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃     │
┃        ┃  ┃     ┊  constraint:
┃        ┃  ┃     ┊      false
┃        ┃  ┃     ┊  subst: .Subst
┃        ┃  ┃     └─ 2 (leaf, target)
┃        ┃  ┃         k: K_CELL:K
┃        ┃  ┃         pc: FINAL_PC_CELL:Int
┃        ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┗━━┓ subst: .Subst
┃        ┃     ┃ constraint:
┃        ┃     ┃     W0:Int <=Int BAL:Int
┃        ┃     │
┃        ┃     ├─ 50 (split)
┃        ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃     │   pc: PC_CELL:Int
┃        ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃
┃        ┃     ┃ (branch)
┃        ┃     ┣━━┓ subst: .Subst
┃        ┃     ┃  ┃ constraint:
┃        ┃     ┃  ┃     BAL:Int <Int W0:Int
┃        ┃     ┃  │
┃        ┃     ┃  ├─ 71
┃        ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃     ┃  │   pc: PC_CELL:Int
┃        ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     ┃  │
┃        ┃     ┃  ┊  constraint:
┃        ┃     ┃  ┊      false
┃        ┃     ┃  ┊  subst: .Subst
┃        ┃     ┃  └─ 2 (leaf, target)
┃        ┃     ┃      k: K_CELL:K
┃        ┃     ┃      pc: FINAL_PC_CELL:Int
┃        ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃     ┃
┃        ┃     ┗━━┓ subst: .Subst
┃        ┃        ┃ constraint: true
┃        ┃        │
┃        ┃        ├─ 72 (split)
┃        ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃        │   pc: PC_CELL:Int
┃        ┃        │   callDepth: CALLDEPTH_CELL:Int
┃        ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃        ┃
┃        ┃        ┃ (branch)
┃        ┃        ┣━━┓ subst: .Subst
┃        ┃        ┃  ┃ constraint:
┃        ┃        ┃  ┃     BAL:Int <Int W0:Int
┃        ┃        ┃  │
┃        ┃        ┃  ├─ 97
┃        ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃        ┃  │   pc: PC_CELL:Int
┃        ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃        ┃  │
┃        ┃        ┃  ┊  constraint:
┃        ┃        ┃  ┊      false
┃        ┃        ┃  ┊  subst: .Subst
┃        ┃        ┃  └─ 2 (leaf, target)
┃        ┃        ┃      k: K_CELL:K
┃        ┃        ┃      pc: FINAL_PC_CELL:Int
┃        ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃        ┃
┃        ┃        ┗━━┓ subst: .Subst
┃        ┃           ┃ constraint: true
┃        ┃           │
┃        ┃           ├─ 98 (split)
┃        ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃           │   pc: PC_CELL:Int
┃        ┃           │   callDepth: CALLDEPTH_CELL:Int
┃        ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃           ┃
┃        ┃           ┃ (branch)
┃        ┃           ┣━━┓ subst: .Subst
┃        ┃           ┃  ┃ constraint:
┃        ┃           ┃  ┃     BAL:Int <Int W0:Int
┃        ┃           ┃  │
┃        ┃           ┃  ├─ 135
┃        ┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃           ┃  │   pc: PC_CELL:Int
┃        ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃           ┃  │
┃        ┃           ┃  ┊  constraint:
┃        ┃           ┃  ┊      false
┃        ┃           ┃  ┊  subst: .Subst
┃        ┃           ┃  └─ 2 (leaf, target)
┃        ┃           ┃      k: K_CELL:K
┃        ┃           ┃      pc: FINAL_PC_CELL:Int
┃        ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃           ┃
┃        ┃           ┗━━┓ subst: .Subst
┃        ┃              ┃ constraint: true
┃        ┃              │
┃        ┃              ├─ 136 (split)
┃        ┃              │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃              │   pc: PC_CELL:Int
┃        ┃              │   callDepth: CALLDEPTH_CELL:Int
┃        ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃              ┃
┃        ┃              ┃ (branch)
┃        ┃              ┣━━┓ subst: .Subst
┃        ┃              ┃  ┃ constraint:
┃        ┃              ┃  ┃     BAL:Int <Int W0:Int
┃        ┃              ┃  │
┃        ┃              ┃  ├─ 177
┃        ┃              ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃              ┃  │   pc: PC_CELL:Int
┃        ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃              ┃  │
┃        ┃              ┃  ┊  constraint:
┃        ┃              ┃  ┊      false
┃        ┃              ┃  ┊  subst: .Subst
┃        ┃              ┃  └─ 2 (leaf, target)
┃        ┃              ┃      k: K_CELL:K
┃        ┃              ┃      pc: FINAL_PC_CELL:Int
┃        ┃              ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃              ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃              ┃
┃        ┃              ┗━━┓ subst: .Subst
┃        ┃                 ┃ constraint: true
┃        ┃                 │
┃        ┃                 ├─ 178 (split)
┃        ┃                 │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                 │   pc: PC_CELL:Int
┃        ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃        ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃                 ┃
┃        ┃                 ┃ (branch)
┃        ┃                 ┣━━┓ subst: .Subst
┃        ┃                 ┃  ┃ constraint:
┃        ┃                 ┃  ┃     BAL:Int <Int W0:Int
┃        ┃                 ┃  │
┃        ┃                 ┃  ├─ 229
┃        ┃                 ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                 ┃  │   pc: PC_CELL:Int
┃        ┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃                 ┃  │
┃        ┃                 ┃  ┊  constraint:
┃        ┃                 ┃  ┊      false
┃        ┃                 ┃  ┊  subst: .Subst
┃        ┃                 ┃  └─ 2 (leaf, target)
┃        ┃                 ┃      k: K_CELL:K
┃        ┃                 ┃      pc: FINAL_PC_CELL:Int
┃        ┃                 ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃                 ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃                 ┃
┃        ┃                 ┗━━┓ subst: .Subst
┃        ┃                    ┃ constraint: true
┃        ┃                    │
┃        ┃                    ├─ 230 (split)
┃        ┃                    │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                    │   pc: PC_CELL:Int
┃        ┃                    │   callDepth: CALLDEPTH_CELL:Int
┃        ┃                    │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃                    ┃
┃        ┃                    ┃ (branch)
┃        ┃                    ┣━━┓ subst: .Subst
┃        ┃                    ┃  ┃ constraint:
┃        ┃                    ┃  ┃     BAL:Int <Int W0:Int
┃        ┃                    ┃  │
┃        ┃                    ┃  ├─ 298
┃        ┃                    ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                    ┃  │   pc: PC_CELL:Int
┃        ┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃                    ┃  │
┃        ┃                    ┃  ┊  constraint:
┃        ┃                    ┃  ┊      false
┃        ┃                    ┃  ┊  subst: .Subst
┃        ┃                    ┃  └─ 2 (leaf, target)
┃        ┃                    ┃      k: K_CELL:K
┃        ┃                    ┃      pc: FINAL_PC_CELL:Int
┃        ┃                    ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃                    ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃                    ┃
┃        ┃                    ┗━━┓ subst: .Subst
┃        ┃                       ┃ constraint: true
┃        ┃                       │
┃        ┃                       ├─ 299 (split)
┃        ┃                       │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                       │   pc: PC_CELL:Int
┃        ┃                       │   callDepth: CALLDEPTH_CELL:Int
┃        ┃                       │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃                       ┃
┃        ┃                       ┃ (branch)
┃        ┃                       ┣━━┓ subst: .Subst
┃        ┃                       ┃  ┃ constraint:
┃        ┃                       ┃  ┃     BAL:Int <Int W0:Int
┃        ┃                       ┃  │
┃        ┃                       ┃  └─ 391 (leaf, pending)
┃        ┃                       ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                       ┃      pc: PC_CELL:Int
┃        ┃                       ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃                       ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃                       ┃
┃        ┃                       ┗━━┓ subst: .Subst
┃        ┃                          ┃ constraint: true
┃        ┃                          │
┃        ┃                          └─ 392 (leaf, pending)
┃        ┃                              k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃                              pc: PC_CELL:Int
┃        ┃                              callDepth: CALLDEPTH_CELL:Int
┃        ┃                              statusCode: STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┗━━┓ subst: .Subst
┃           ┃ constraint: true
┃           │
┃           ├─ 28 (split)
┃           │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃           │   pc: PC_CELL:Int
┃           │   callDepth: CALLDEPTH_CELL:Int
┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃
┃           ┃ (branch)
┃           ┣━━┓ subst: .Subst
┃           ┃  ┃ constraint:
┃           ┃  ┃     ID_CELL:Int ==Int WO:Int
┃           ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃           ┃  │
┃           ┃  ├─ 40
┃           ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃           ┃  │   pc: PC_CELL:Int
┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  │
┃           ┃  │  (3 steps)
┃           ┃  ├─ 58 (split)
┃           ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃           ┃  │   pc: PC_CELL:Int
┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┃ (branch)
┃           ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃ constraint:
┃           ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃           ┃  ┃  │
┃           ┃  ┃  ├─ 75
┃           ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃           ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  │
┃           ┃  ┃  │  (13 steps)
┃           ┃  ┃  ├─ 164
┃           ┃  ┃  │   k: K_CELL:K
┃           ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃           ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃           ┃  ┃  │
┃           ┃  ┃  ┊  constraint:
┃           ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃           ┃  ┃  ┊  subst: ...
┃           ┃  ┃  └─ 2 (leaf, target)
┃           ┃  ┃      k: K_CELL:K
┃           ┃  ┃      pc: FINAL_PC_CELL:Int
┃           ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┗━━┓ subst: .Subst
┃           ┃     ┃ constraint:
┃           ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃           ┃     │
┃           ┃     ├─ 76
┃           ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃           ┃     │   pc: PC_CELL:Int
┃           ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     │
┃           ┃     │  (1 step)
┃           ┃     ├─ 101 (split)
┃           ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃           ┃     │   pc: PC_CELL:Int
┃           ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃
┃           ┃     ┃ (branch)
┃           ┃     ┣━━┓ subst: .Subst
┃           ┃     ┃  ┃ constraint:
┃           ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃           ┃     ┃  │
┃           ┃     ┃  ├─ 131
┃           ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃           ┃     ┃  │   pc: PC_CELL:Int
┃           ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃  │
┃           ┃     ┃  │  (1 step)
┃           ┃     ┃  ├─ 174 (split)
┃           ┃     ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃           ┃     ┃  │   pc: PC_CELL:Int
┃           ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃  ┃
┃           ┃     ┃  ┃ (branch)
┃           ┃     ┃  ┣━━┓ subst: .Subst
┃           ┃     ┃  ┃  ┃ constraint:
┃           ┃     ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃           ┃     ┃  ┃  │
┃           ┃     ┃  ┃  ├─ 225
┃           ┃     ┃  ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃           ┃     ┃  ┃  │   pc: PC_CELL:Int
┃           ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃  ┃  │
┃           ┃     ┃  ┃  │  (11 steps)
┃           ┃     ┃  ┃  ├─ 342
┃           ┃     ┃  ┃  │   k: K_CELL:K
┃           ┃     ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃           ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃  ┃  │   statusCode: EVMC_NONCE_EXCEEDED
┃           ┃     ┃  ┃  │
┃           ┃     ┃  ┃  ┊  constraint:
┃           ┃     ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃           ┃     ┃  ┃  ┊  subst: ...
┃           ┃     ┃  ┃  └─ 2 (leaf, target)
┃           ┃     ┃  ┃      k: K_CELL:K
┃           ┃     ┃  ┃      pc: FINAL_PC_CELL:Int
┃           ┃     ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃     ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃     ┃  ┃
┃           ┃     ┃  ┗━━┓ subst: .Subst
┃           ┃     ┃     ┃ constraint:
┃           ┃     ┃     ┃     0 <=Int NONCE_CELL:Int
┃           ┃     ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃           ┃     ┃     │
┃           ┃     ┃     ├─ 226
┃           ┃     ┃     │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃           ┃     ┃     │   pc: PC_CELL:Int
┃           ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃     │
┃           ┃     ┃     │  (5 steps)
┃           ┃     ┃     ├─ 295 (split)
┃           ┃     ┃     │   k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃           ┃     ┃     │   pc: PC_CELL:Int
┃           ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃     ┃
┃           ┃     ┃     ┃ (branch)
┃           ┃     ┃     ┣━━┓ subst: .Subst
┃           ┃     ┃     ┃  ┃ constraint:
┃           ┃     ┃     ┃  ┃     WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int )
┃           ┃     ┃     ┃  │
┃           ┃     ┃     ┃  └─ 386 (leaf, pending)
┃           ┃     ┃     ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃           ┃     ┃     ┃      pc: PC_CELL:Int
┃           ┃     ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃     ┃
┃           ┃     ┃     ┣━━┓ subst: .Subst
┃           ┃     ┃     ┃  ┃ constraint:
┃           ┃     ┃     ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃           ┃     ┃     ┃  ┃     ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) )
┃           ┃     ┃     ┃  ┃     ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃           ┃     ┃     ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap )
┃           ┃     ┃     ┃  │
┃           ┃     ┃     ┃  └─ 387 (leaf, pending)
┃           ┃     ┃     ┃      k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃           ┃     ┃     ┃      pc: PC_CELL:Int
┃           ┃     ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃     ┃
┃           ┃     ┃     ┗━━┓ subst: .Subst
┃           ┃     ┃        ┃ constraint: true
┃           ┃     ┃        │
┃           ┃     ┃        └─ 388 (leaf, pending)
┃           ┃     ┃            k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃           ┃     ┃            pc: PC_CELL:Int
┃           ┃     ┃            callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃            statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃
┃           ┃     ┗━━┓ subst: .Subst
┃           ┃        ┃ constraint:
┃           ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃           ┃        │
┃           ┃        ├─ 132
┃           ┃        │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃           ┃        │   pc: PC_CELL:Int
┃           ┃        │   callDepth: CALLDEPTH_CELL:Int
┃           ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃        │
┃           ┃        │  (12 steps)
┃           ┃        ├─ 251
┃           ┃        │   k: K_CELL:K
┃           ┃        │   pc: ( PC_CELL:Int +Int 1 )
┃           ┃        │   callDepth: CALLDEPTH_CELL:Int
┃           ┃        │   statusCode: EVMC_CALL_DEPTH_EXCEEDED
┃           ┃        │
┃           ┃        ┊  constraint:
┃           ┃        ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃           ┃        ┊  subst: ...
┃           ┃        └─ 2 (leaf, target)
┃           ┃            k: K_CELL:K
┃           ┃            pc: FINAL_PC_CELL:Int
┃           ┃            callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃            statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃
┃           ┣━━┓ subst: .Subst
┃           ┃  ┃ constraint:
┃           ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃           ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃           ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃           ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃           ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃           ┃  │
┃           ┃  ├─ 41
┃           ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃           ┃  │   pc: PC_CELL:Int
┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  │
┃           ┃  │  (3 steps)
┃           ┃  ├─ 59 (split)
┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  │   pc: PC_CELL:Int
┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┃ (branch)
┃           ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃ constraint:
┃           ┃  ┃  ┃     BAL:Int <Int W0:Int
┃           ┃  ┃  │
┃           ┃  ┃  ├─ 77 (split)
┃           ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃
┃           ┃  ┃  ┃ (branch)
┃           ┃  ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃ constraint: true
┃           ┃  ┃  ┃  │
┃           ┃  ┃  ┃  ├─ 102 (split)
┃           ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃ (branch)
┃           ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃ constraint: true
┃           ┃  ┃  ┃  ┃  │
┃           ┃  ┃  ┃  ┃  ├─ 139 (split)
┃           ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃ (branch)
┃           ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃           ┃  ┃  ┃  ┃  ┃  │
┃           ┃  ┃  ┃  ┃  ┃  ├─ 181 (split)
┃           ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃           ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃           ┃  ┃  ┃  ┃  ┃  ┃  │
┃           ┃  ┃  ┃  ┃  ┃  ┃  ├─ 234 (split)
┃           ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ├─ 303 (split)
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃  └─ 396 (leaf, pending)
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃     └─ 397 (leaf, pending)
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃           ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃  ┃  ┃     ├─ 304
┃           ┃  ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃           ┃  ┃  ┃  ┃  ┃  ┃     ┊      false
┃           ┃  ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃           ┃  ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃           ┃  ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃           ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃  ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃  ┃     ├─ 235
┃           ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃           ┃  ┃  ┃  ┃  ┃     ┊      false
┃           ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃           ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃           ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃           ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃           ┃  ┃  ┃  ┃     ┃ constraint:
┃           ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃     ├─ 182
┃           ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃           ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃     │
┃           ┃  ┃  ┃  ┃     ┊  constraint:
┃           ┃  ┃  ┃  ┃     ┊      false
┃           ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃           ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃           ┃  ┃  ┃  ┃         k: K_CELL:K
┃           ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃           ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃  ┃
┃           ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃           ┃  ┃  ┃     ┃ constraint:
┃           ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃  ┃  ┃     │
┃           ┃  ┃  ┃     ├─ 140
┃           ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃  ┃     │   pc: PC_CELL:Int
┃           ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃     │
┃           ┃  ┃  ┃     ┊  constraint:
┃           ┃  ┃  ┃     ┊      false
┃           ┃  ┃  ┃     ┊  subst: .Subst
┃           ┃  ┃  ┃     └─ 2 (leaf, target)
┃           ┃  ┃  ┃         k: K_CELL:K
┃           ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃           ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃  ┃  ┃
┃           ┃  ┃  ┗━━┓ subst: .Subst
┃           ┃  ┃     ┃ constraint:
┃           ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃  ┃     │
┃           ┃  ┃     ├─ 103
┃           ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  ┃     │   pc: PC_CELL:Int
┃           ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃     │
┃           ┃  ┃     ┊  constraint:
┃           ┃  ┃     ┊      false
┃           ┃  ┃     ┊  subst: .Subst
┃           ┃  ┃     └─ 2 (leaf, target)
┃           ┃  ┃         k: K_CELL:K
┃           ┃  ┃         pc: FINAL_PC_CELL:Int
┃           ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┗━━┓ subst: .Subst
┃           ┃     ┃ constraint:
┃           ┃     ┃     W0:Int <=Int BAL:Int
┃           ┃     │
┃           ┃     ├─ 78 (split)
┃           ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃     │   pc: PC_CELL:Int
┃           ┃     │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃
┃           ┃     ┃ (branch)
┃           ┃     ┣━━┓ subst: .Subst
┃           ┃     ┃  ┃ constraint:
┃           ┃     ┃  ┃     BAL:Int <Int W0:Int
┃           ┃     ┃  │
┃           ┃     ┃  ├─ 104
┃           ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃     ┃  │   pc: PC_CELL:Int
┃           ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃     ┃  │
┃           ┃     ┃  ┊  constraint:
┃           ┃     ┃  ┊      false
┃           ┃     ┃  ┊  subst: .Subst
┃           ┃     ┃  └─ 2 (leaf, target)
┃           ┃     ┃      k: K_CELL:K
┃           ┃     ┃      pc: FINAL_PC_CELL:Int
┃           ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃     ┃
┃           ┃     ┗━━┓ subst: .Subst
┃           ┃        ┃ constraint: true
┃           ┃        │
┃           ┃        ├─ 105 (split)
┃           ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃        │   pc: PC_CELL:Int
┃           ┃        │   callDepth: CALLDEPTH_CELL:Int
┃           ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃        ┃
┃           ┃        ┃ (branch)
┃           ┃        ┣━━┓ subst: .Subst
┃           ┃        ┃  ┃ constraint:
┃           ┃        ┃  ┃     BAL:Int <Int W0:Int
┃           ┃        ┃  │
┃           ┃        ┃  ├─ 141
┃           ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃        ┃  │   pc: PC_CELL:Int
┃           ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃        ┃  │
┃           ┃        ┃  ┊  constraint:
┃           ┃        ┃  ┊      false
┃           ┃        ┃  ┊  subst: .Subst
┃           ┃        ┃  └─ 2 (leaf, target)
┃           ┃        ┃      k: K_CELL:K
┃           ┃        ┃      pc: FINAL_PC_CELL:Int
┃           ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃        ┃
┃           ┃        ┗━━┓ subst: .Subst
┃           ┃           ┃ constraint: true
┃           ┃           │
┃           ┃           ├─ 142 (split)
┃           ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃           │   pc: PC_CELL:Int
┃           ┃           │   callDepth: CALLDEPTH_CELL:Int
┃           ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃           ┃
┃           ┃           ┃ (branch)
┃           ┃           ┣━━┓ subst: .Subst
┃           ┃           ┃  ┃ constraint:
┃           ┃           ┃  ┃     BAL:Int <Int W0:Int
┃           ┃           ┃  │
┃           ┃           ┃  ├─ 183
┃           ┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃           ┃  │   pc: PC_CELL:Int
┃           ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃           ┃  │
┃           ┃           ┃  ┊  constraint:
┃           ┃           ┃  ┊      false
┃           ┃           ┃  ┊  subst: .Subst
┃           ┃           ┃  └─ 2 (leaf, target)
┃           ┃           ┃      k: K_CELL:K
┃           ┃           ┃      pc: FINAL_PC_CELL:Int
┃           ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃           ┃
┃           ┃           ┗━━┓ subst: .Subst
┃           ┃              ┃ constraint: true
┃           ┃              │
┃           ┃              ├─ 184 (split)
┃           ┃              │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃              │   pc: PC_CELL:Int
┃           ┃              │   callDepth: CALLDEPTH_CELL:Int
┃           ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃              ┃
┃           ┃              ┃ (branch)
┃           ┃              ┣━━┓ subst: .Subst
┃           ┃              ┃  ┃ constraint:
┃           ┃              ┃  ┃     BAL:Int <Int W0:Int
┃           ┃              ┃  │
┃           ┃              ┃  ├─ 236
┃           ┃              ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃              ┃  │   pc: PC_CELL:Int
┃           ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃              ┃  │
┃           ┃              ┃  ┊  constraint:
┃           ┃              ┃  ┊      false
┃           ┃              ┃  ┊  subst: .Subst
┃           ┃              ┃  └─ 2 (leaf, target)
┃           ┃              ┃      k: K_CELL:K
┃           ┃              ┃      pc: FINAL_PC_CELL:Int
┃           ┃              ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃              ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃              ┃
┃           ┃              ┗━━┓ subst: .Subst
┃           ┃                 ┃ constraint: true
┃           ┃                 │
┃           ┃                 ├─ 237 (split)
┃           ┃                 │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃                 │   pc: PC_CELL:Int
┃           ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃           ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃                 ┃
┃           ┃                 ┃ (branch)
┃           ┃                 ┣━━┓ subst: .Subst
┃           ┃                 ┃  ┃ constraint:
┃           ┃                 ┃  ┃     BAL:Int <Int W0:Int
┃           ┃                 ┃  │
┃           ┃                 ┃  ├─ 305
┃           ┃                 ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃                 ┃  │   pc: PC_CELL:Int
┃           ┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃                 ┃  │
┃           ┃                 ┃  ┊  constraint:
┃           ┃                 ┃  ┊      false
┃           ┃                 ┃  ┊  subst: .Subst
┃           ┃                 ┃  └─ 2 (leaf, target)
┃           ┃                 ┃      k: K_CELL:K
┃           ┃                 ┃      pc: FINAL_PC_CELL:Int
┃           ┃                 ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃           ┃                 ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃           ┃                 ┃
┃           ┃                 ┗━━┓ subst: .Subst
┃           ┃                    ┃ constraint: true
┃           ┃                    │
┃           ┃                    ├─ 306 (split)
┃           ┃                    │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃                    │   pc: PC_CELL:Int
┃           ┃                    │   callDepth: CALLDEPTH_CELL:Int
┃           ┃                    │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃                    ┃
┃           ┃                    ┃ (branch)
┃           ┃                    ┣━━┓ subst: .Subst
┃           ┃                    ┃  ┃ constraint:
┃           ┃                    ┃  ┃     BAL:Int <Int W0:Int
┃           ┃                    ┃  │
┃           ┃                    ┃  └─ 398 (leaf, pending)
┃           ┃                    ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃                    ┃      pc: PC_CELL:Int
┃           ┃                    ┃      callDepth: CALLDEPTH_CELL:Int
┃           ┃                    ┃      statusCode: STATUSCODE_CELL:StatusCode
┃           ┃                    ┃
┃           ┃                    ┗━━┓ subst: .Subst
┃           ┃                       ┃ constraint: true
┃           ┃                       │
┃           ┃                       └─ 399 (leaf, pending)
┃           ┃                           k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃                           pc: PC_CELL:Int
┃           ┃                           callDepth: CALLDEPTH_CELL:Int
┃           ┃                           statusCode: STATUSCODE_CELL:StatusCode
┃           ┃
┃           ┗━━┓ subst: .Subst
┃              ┃ constraint: true
┃              │
┃              ├─ 42 (split)
┃              │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃              │   pc: PC_CELL:Int
┃              │   callDepth: CALLDEPTH_CELL:Int
┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃
┃              ┃ (branch)
┃              ┣━━┓ subst: .Subst
┃              ┃  ┃ constraint:
┃              ┃  ┃     ID_CELL:Int ==Int WO:Int
┃              ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃              ┃  │
┃              ┃  ├─ 60
┃              ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃              ┃  │   pc: PC_CELL:Int
┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  │
┃              ┃  │  (3 steps)
┃              ┃  ├─ 83 (split)
┃              ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃              ┃  │   pc: PC_CELL:Int
┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃
┃              ┃  ┃ (branch)
┃              ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃ constraint:
┃              ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃              ┃  ┃  │
┃              ┃  ┃  ├─ 110
┃              ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃              ┃  ┃  │   pc: PC_CELL:Int
┃              ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  │
┃              ┃  ┃  │  (13 steps)
┃              ┃  ┃  ├─ 231
┃              ┃  ┃  │   k: K_CELL:K
┃              ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃              ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃              ┃  ┃  │
┃              ┃  ┃  ┊  constraint:
┃              ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃              ┃  ┃  ┊  subst: ...
┃              ┃  ┃  └─ 2 (leaf, target)
┃              ┃  ┃      k: K_CELL:K
┃              ┃  ┃      pc: FINAL_PC_CELL:Int
┃              ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃  ┃
┃              ┃  ┗━━┓ subst: .Subst
┃              ┃     ┃ constraint:
┃              ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃              ┃     │
┃              ┃     ├─ 111
┃              ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃              ┃     │   pc: PC_CELL:Int
┃              ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     │
┃              ┃     │  (1 step)
┃              ┃     ├─ 147 (split)
┃              ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃              ┃     │   pc: PC_CELL:Int
┃              ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃
┃              ┃     ┃ (branch)
┃              ┃     ┣━━┓ subst: .Subst
┃              ┃     ┃  ┃ constraint:
┃              ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃              ┃     ┃  │
┃              ┃     ┃  ├─ 187
┃              ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃              ┃     ┃  │   pc: PC_CELL:Int
┃              ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃  │
┃              ┃     ┃  │  (1 step)
┃              ┃     ┃  ├─ 240 (split)
┃              ┃     ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃              ┃     ┃  │   pc: PC_CELL:Int
┃              ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃  ┃
┃              ┃     ┃  ┃ (branch)
┃              ┃     ┃  ┣━━┓ subst: .Subst
┃              ┃     ┃  ┃  ┃ constraint:
┃              ┃     ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃              ┃     ┃  ┃  │
┃              ┃     ┃  ┃  ├─ 309
┃              ┃     ┃  ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃              ┃     ┃  ┃  │   pc: PC_CELL:Int
┃              ┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃  ┃  │
┃              ┃     ┃  ┃  │  (11 steps)
┃              ┃     ┃  ┃  └─ 442 (leaf, pending)
┃              ┃     ┃  ┃      k: K_CELL:K
┃              ┃     ┃  ┃      pc: ( PC_CELL:Int +Int 1 )
┃              ┃     ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃  ┃      statusCode: EVMC_NONCE_EXCEEDED
┃              ┃     ┃  ┃
┃              ┃     ┃  ┗━━┓ subst: .Subst
┃              ┃     ┃     ┃ constraint:
┃              ┃     ┃     ┃     0 <=Int NONCE_CELL:Int
┃              ┃     ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃              ┃     ┃     │
┃              ┃     ┃     ├─ 310
┃              ┃     ┃     │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃              ┃     ┃     │   pc: PC_CELL:Int
┃              ┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃     │
┃              ┃     ┃     │  (5 steps)
┃              ┃     ┃     └─ 402 (leaf, pending)
┃              ┃     ┃         k: #newAccount #newAddr ( WO:Int , NONCE_CELL:Int ) ~> #transferFunds WO:Int #newAd ...
┃              ┃     ┃         pc: PC_CELL:Int
┃              ┃     ┃         callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃         statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃
┃              ┃     ┗━━┓ subst: .Subst
┃              ┃        ┃ constraint:
┃              ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃              ┃        │
┃              ┃        ├─ 188
┃              ┃        │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃              ┃        │   pc: PC_CELL:Int
┃              ┃        │   callDepth: CALLDEPTH_CELL:Int
┃              ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃        │
┃              ┃        │  (12 steps)
┃              ┃        ├─ 320
┃              ┃        │   k: K_CELL:K
┃              ┃        │   pc: ( PC_CELL:Int +Int 1 )
┃              ┃        │   callDepth: CALLDEPTH_CELL:Int
┃              ┃        │   statusCode: EVMC_CALL_DEPTH_EXCEEDED
┃              ┃        │
┃              ┃        ┊  constraint:
┃              ┃        ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃              ┃        ┊  subst: ...
┃              ┃        └─ 2 (leaf, target)
┃              ┃            k: K_CELL:K
┃              ┃            pc: FINAL_PC_CELL:Int
┃              ┃            callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃            statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃
┃              ┣━━┓ subst: .Subst
┃              ┃  ┃ constraint:
┃              ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃              ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃              ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃              ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃              ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃              ┃  │
┃              ┃  ├─ 61
┃              ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃              ┃  │   pc: PC_CELL:Int
┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  │
┃              ┃  │  (3 steps)
┃              ┃  ├─ 84 (split)
┃              ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  │   pc: PC_CELL:Int
┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃
┃              ┃  ┃ (branch)
┃              ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃ constraint:
┃              ┃  ┃  ┃     BAL:Int <Int W0:Int
┃              ┃  ┃  │
┃              ┃  ┃  ├─ 112 (split)
┃              ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  │   pc: PC_CELL:Int
┃              ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃
┃              ┃  ┃  ┃ (branch)
┃              ┃  ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃ constraint: true
┃              ┃  ┃  ┃  │
┃              ┃  ┃  ┃  ├─ 148 (split)
┃              ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  │   pc: PC_CELL:Int
┃              ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃ (branch)
┃              ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃ constraint: true
┃              ┃  ┃  ┃  ┃  │
┃              ┃  ┃  ┃  ┃  ├─ 191 (split)
┃              ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃  ┃ (branch)
┃              ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃              ┃  ┃  ┃  ┃  ┃  │
┃              ┃  ┃  ┃  ┃  ┃  ├─ 243 (split)
┃              ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃              ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃              ┃  ┃  ┃  ┃  ┃  ┃  │
┃              ┃  ┃  ┃  ┃  ┃  ┃  ├─ 313 (split)
┃              ┃  ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃  │
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃  └─ 405 (leaf, pending)
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃              ┃  ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃     │
┃              ┃  ┃  ┃  ┃  ┃  ┃     └─ 406 (leaf, pending)
┃              ┃  ┃  ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃              ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃              ┃  ┃  ┃  ┃  ┃     │
┃              ┃  ┃  ┃  ┃  ┃     ├─ 314
┃              ┃  ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃     │
┃              ┃  ┃  ┃  ┃  ┃     ┊  constraint:
┃              ┃  ┃  ┃  ┃  ┃     ┊      false
┃              ┃  ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃              ┃  ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃              ┃  ┃  ┃  ┃  ┃         k: K_CELL:K
┃              ┃  ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃              ┃  ┃  ┃  ┃     ┃ constraint:
┃              ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃              ┃  ┃  ┃  ┃     │
┃              ┃  ┃  ┃  ┃     ├─ 244
┃              ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃              ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃     │
┃              ┃  ┃  ┃  ┃     ┊  constraint:
┃              ┃  ┃  ┃  ┃     ┊      false
┃              ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃              ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃              ┃  ┃  ┃  ┃         k: K_CELL:K
┃              ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃              ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃  ┃
┃              ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃              ┃  ┃  ┃     ┃ constraint:
┃              ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃              ┃  ┃  ┃     │
┃              ┃  ┃  ┃     ├─ 192
┃              ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃  ┃     │   pc: PC_CELL:Int
┃              ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃     │
┃              ┃  ┃  ┃     ┊  constraint:
┃              ┃  ┃  ┃     ┊      false
┃              ┃  ┃  ┃     ┊  subst: .Subst
┃              ┃  ┃  ┃     └─ 2 (leaf, target)
┃              ┃  ┃  ┃         k: K_CELL:K
┃              ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃              ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃  ┃  ┃
┃              ┃  ┃  ┗━━┓ subst: .Subst
┃              ┃  ┃     ┃ constraint:
┃              ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃              ┃  ┃     │
┃              ┃  ┃     ├─ 149
┃              ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃  ┃     │   pc: PC_CELL:Int
┃              ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  ┃     │
┃              ┃  ┃     ┊  constraint:
┃              ┃  ┃     ┊      false
┃              ┃  ┃     ┊  subst: .Subst
┃              ┃  ┃     └─ 2 (leaf, target)
┃              ┃  ┃         k: K_CELL:K
┃              ┃  ┃         pc: FINAL_PC_CELL:Int
┃              ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃  ┃
┃              ┃  ┗━━┓ subst: .Subst
┃              ┃     ┃ constraint:
┃              ┃     ┃     W0:Int <=Int BAL:Int
┃              ┃     │
┃              ┃     ├─ 113 (split)
┃              ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃     │   pc: PC_CELL:Int
┃              ┃     │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃
┃              ┃     ┃ (branch)
┃              ┃     ┣━━┓ subst: .Subst
┃              ┃     ┃  ┃ constraint:
┃              ┃     ┃  ┃     BAL:Int <Int W0:Int
┃              ┃     ┃  │
┃              ┃     ┃  ├─ 150
┃              ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃     ┃  │   pc: PC_CELL:Int
┃              ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃     ┃  │
┃              ┃     ┃  ┊  constraint:
┃              ┃     ┃  ┊      false
┃              ┃     ┃  ┊  subst: .Subst
┃              ┃     ┃  └─ 2 (leaf, target)
┃              ┃     ┃      k: K_CELL:K
┃              ┃     ┃      pc: FINAL_PC_CELL:Int
┃              ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃     ┃
┃              ┃     ┗━━┓ subst: .Subst
┃              ┃        ┃ constraint: true
┃              ┃        │
┃              ┃        ├─ 151 (split)
┃              ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃        │   pc: PC_CELL:Int
┃              ┃        │   callDepth: CALLDEPTH_CELL:Int
┃              ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃        ┃
┃              ┃        ┃ (branch)
┃              ┃        ┣━━┓ subst: .Subst
┃              ┃        ┃  ┃ constraint:
┃              ┃        ┃  ┃     BAL:Int <Int W0:Int
┃              ┃        ┃  │
┃              ┃        ┃  ├─ 193
┃              ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃        ┃  │   pc: PC_CELL:Int
┃              ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃        ┃  │
┃              ┃        ┃  ┊  constraint:
┃              ┃        ┃  ┊      false
┃              ┃        ┃  ┊  subst: .Subst
┃              ┃        ┃  └─ 2 (leaf, target)
┃              ┃        ┃      k: K_CELL:K
┃              ┃        ┃      pc: FINAL_PC_CELL:Int
┃              ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃        ┃
┃              ┃        ┗━━┓ subst: .Subst
┃              ┃           ┃ constraint: true
┃              ┃           │
┃              ┃           ├─ 194 (split)
┃              ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃           │   pc: PC_CELL:Int
┃              ┃           │   callDepth: CALLDEPTH_CELL:Int
┃              ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃           ┃
┃              ┃           ┃ (branch)
┃              ┃           ┣━━┓ subst: .Subst
┃              ┃           ┃  ┃ constraint:
┃              ┃           ┃  ┃     BAL:Int <Int W0:Int
┃              ┃           ┃  │
┃              ┃           ┃  ├─ 245
┃              ┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃           ┃  │   pc: PC_CELL:Int
┃              ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃           ┃  │
┃              ┃           ┃  ┊  constraint:
┃              ┃           ┃  ┊      false
┃              ┃           ┃  ┊  subst: .Subst
┃              ┃           ┃  └─ 2 (leaf, target)
┃              ┃           ┃      k: K_CELL:K
┃              ┃           ┃      pc: FINAL_PC_CELL:Int
┃              ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃           ┃
┃              ┃           ┗━━┓ subst: .Subst
┃              ┃              ┃ constraint: true
┃              ┃              │
┃              ┃              ├─ 246 (split)
┃              ┃              │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃              │   pc: PC_CELL:Int
┃              ┃              │   callDepth: CALLDEPTH_CELL:Int
┃              ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃              ┃
┃              ┃              ┃ (branch)
┃              ┃              ┣━━┓ subst: .Subst
┃              ┃              ┃  ┃ constraint:
┃              ┃              ┃  ┃     BAL:Int <Int W0:Int
┃              ┃              ┃  │
┃              ┃              ┃  ├─ 315
┃              ┃              ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃              ┃  │   pc: PC_CELL:Int
┃              ┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃              ┃  │
┃              ┃              ┃  ┊  constraint:
┃              ┃              ┃  ┊      false
┃              ┃              ┃  ┊  subst: .Subst
┃              ┃              ┃  └─ 2 (leaf, target)
┃              ┃              ┃      k: K_CELL:K
┃              ┃              ┃      pc: FINAL_PC_CELL:Int
┃              ┃              ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃              ┃              ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃              ┃              ┃
┃              ┃              ┗━━┓ subst: .Subst
┃              ┃                 ┃ constraint: true
┃              ┃                 │
┃              ┃                 ├─ 316 (split)
┃              ┃                 │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃                 │   pc: PC_CELL:Int
┃              ┃                 │   callDepth: CALLDEPTH_CELL:Int
┃              ┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃                 ┃
┃              ┃                 ┃ (branch)
┃              ┃                 ┣━━┓ subst: .Subst
┃              ┃                 ┃  ┃ constraint:
┃              ┃                 ┃  ┃     BAL:Int <Int W0:Int
┃              ┃                 ┃  │
┃              ┃                 ┃  └─ 407 (leaf, pending)
┃              ┃                 ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃                 ┃      pc: PC_CELL:Int
┃              ┃                 ┃      callDepth: CALLDEPTH_CELL:Int
┃              ┃                 ┃      statusCode: STATUSCODE_CELL:StatusCode
┃              ┃                 ┃
┃              ┃                 ┗━━┓ subst: .Subst
┃              ┃                    ┃ constraint: true
┃              ┃                    │
┃              ┃                    └─ 408 (leaf, pending)
┃              ┃                        k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃                        pc: PC_CELL:Int
┃              ┃                        callDepth: CALLDEPTH_CELL:Int
┃              ┃                        statusCode: STATUSCODE_CELL:StatusCode
┃              ┃
┃              ┗━━┓ subst: .Subst
┃                 ┃ constraint: true
┃                 │
┃                 ├─ 62 (split)
┃                 │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                 │   pc: PC_CELL:Int
┃                 │   callDepth: CALLDEPTH_CELL:Int
┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃
┃                 ┃ (branch)
┃                 ┣━━┓ subst: .Subst
┃                 ┃  ┃ constraint:
┃                 ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                 ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                 ┃  │
┃                 ┃  ├─ 85
┃                 ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                 ┃  │   pc: PC_CELL:Int
┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  │
┃                 ┃  │  (3 steps)
┃                 ┃  ├─ 114 (split)
┃                 ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                 ┃  │   pc: PC_CELL:Int
┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃
┃                 ┃  ┃ (branch)
┃                 ┃  ┣━━┓ subst: .Subst
┃                 ┃  ┃  ┃ constraint:
┃                 ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃                 ┃  ┃  │
┃                 ┃  ┃  ├─ 152
┃                 ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                 ┃  ┃  │   pc: PC_CELL:Int
┃                 ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  │
┃                 ┃  ┃  │  (13 steps)
┃                 ┃  ┃  ├─ 260
┃                 ┃  ┃  │   k: K_CELL:K
┃                 ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃                 ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃                 ┃  ┃  │
┃                 ┃  ┃  ┊  constraint:
┃                 ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃                 ┃  ┃  ┊  subst: ...
┃                 ┃  ┃  └─ 2 (leaf, target)
┃                 ┃  ┃      k: K_CELL:K
┃                 ┃  ┃      pc: FINAL_PC_CELL:Int
┃                 ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃  ┃
┃                 ┃  ┗━━┓ subst: .Subst
┃                 ┃     ┃ constraint:
┃                 ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃                 ┃     │
┃                 ┃     ├─ 153
┃                 ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                 ┃     │   pc: PC_CELL:Int
┃                 ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     │
┃                 ┃     │  (1 step)
┃                 ┃     ├─ 195 (split)
┃                 ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                 ┃     │   pc: PC_CELL:Int
┃                 ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃
┃                 ┃     ┃ (branch)
┃                 ┃     ┣━━┓ subst: .Subst
┃                 ┃     ┃  ┃ constraint:
┃                 ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃                 ┃     ┃  │
┃                 ┃     ┃  ├─ 247
┃                 ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                 ┃     ┃  │   pc: PC_CELL:Int
┃                 ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃  │
┃                 ┃     ┃  │  (1 step)
┃                 ┃     ┃  ├─ 317 (split)
┃                 ┃     ┃  │   k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃                 ┃     ┃  │   pc: PC_CELL:Int
┃                 ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃  ┃
┃                 ┃     ┃  ┃ (branch)
┃                 ┃     ┃  ┣━━┓ subst: .Subst
┃                 ┃     ┃  ┃  ┃ constraint:
┃                 ┃     ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃                 ┃     ┃  ┃  │
┃                 ┃     ┃  ┃  └─ 409 (leaf, pending)
┃                 ┃     ┃  ┃      k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃                 ┃     ┃  ┃      pc: PC_CELL:Int
┃                 ┃     ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                 ┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃  ┃
┃                 ┃     ┃  ┗━━┓ subst: .Subst
┃                 ┃     ┃     ┃ constraint:
┃                 ┃     ┃     ┃     0 <=Int NONCE_CELL:Int
┃                 ┃     ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃                 ┃     ┃     │
┃                 ┃     ┃     └─ 410 (leaf, pending)
┃                 ┃     ┃         k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃                 ┃     ┃         pc: PC_CELL:Int
┃                 ┃     ┃         callDepth: CALLDEPTH_CELL:Int
┃                 ┃     ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃
┃                 ┃     ┗━━┓ subst: .Subst
┃                 ┃        ┃ constraint:
┃                 ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃                 ┃        │
┃                 ┃        ├─ 248
┃                 ┃        │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                 ┃        │   pc: PC_CELL:Int
┃                 ┃        │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃        │
┃                 ┃        │  (12 steps)
┃                 ┃        ├─ 362
┃                 ┃        │   k: K_CELL:K
┃                 ┃        │   pc: ( PC_CELL:Int +Int 1 )
┃                 ┃        │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃        │   statusCode: EVMC_CALL_DEPTH_EXCEEDED
┃                 ┃        │
┃                 ┃        ┊  constraint:
┃                 ┃        ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃                 ┃        ┊  subst: ...
┃                 ┃        └─ 2 (leaf, target)
┃                 ┃            k: K_CELL:K
┃                 ┃            pc: FINAL_PC_CELL:Int
┃                 ┃            callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃            statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃
┃                 ┣━━┓ subst: .Subst
┃                 ┃  ┃ constraint:
┃                 ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                 ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                 ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                 ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                 ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                 ┃  │
┃                 ┃  ├─ 86
┃                 ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                 ┃  │   pc: PC_CELL:Int
┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  │
┃                 ┃  │  (3 steps)
┃                 ┃  ├─ 115 (split)
┃                 ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  │   pc: PC_CELL:Int
┃                 ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃
┃                 ┃  ┃ (branch)
┃                 ┃  ┣━━┓ subst: .Subst
┃                 ┃  ┃  ┃ constraint:
┃                 ┃  ┃  ┃     BAL:Int <Int W0:Int
┃                 ┃  ┃  │
┃                 ┃  ┃  ├─ 154 (split)
┃                 ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  │   pc: PC_CELL:Int
┃                 ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃
┃                 ┃  ┃  ┃ (branch)
┃                 ┃  ┃  ┣━━┓ subst: .Subst
┃                 ┃  ┃  ┃  ┃ constraint: true
┃                 ┃  ┃  ┃  │
┃                 ┃  ┃  ┃  ├─ 196 (split)
┃                 ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃  │   pc: PC_CELL:Int
┃                 ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃
┃                 ┃  ┃  ┃  ┃ (branch)
┃                 ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃                 ┃  ┃  ┃  ┃  ┃ constraint: true
┃                 ┃  ┃  ┃  ┃  │
┃                 ┃  ┃  ┃  ┃  ├─ 249 (split)
┃                 ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃                 ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃  ┃
┃                 ┃  ┃  ┃  ┃  ┃ (branch)
┃                 ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃                 ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃                 ┃  ┃  ┃  ┃  ┃  │
┃                 ┃  ┃  ┃  ┃  ┃  ├─ 318 (split)
┃                 ┃  ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃                 ┃  ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃  ┃  ┃
┃                 ┃  ┃  ┃  ┃  ┃  ┃ (branch)
┃                 ┃  ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃                 ┃  ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃                 ┃  ┃  ┃  ┃  ┃  ┃  │
┃                 ┃  ┃  ┃  ┃  ┃  ┃  └─ 411 (leaf, pending)
┃                 ┃  ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃                 ┃  ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃  ┃  ┃
┃                 ┃  ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃                 ┃  ┃  ┃  ┃  ┃     ┃ constraint:
┃                 ┃  ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                 ┃  ┃  ┃  ┃  ┃     │
┃                 ┃  ┃  ┃  ┃  ┃     └─ 412 (leaf, pending)
┃                 ┃  ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃                 ┃  ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃  ┃
┃                 ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃                 ┃  ┃  ┃  ┃     ┃ constraint:
┃                 ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                 ┃  ┃  ┃  ┃     │
┃                 ┃  ┃  ┃  ┃     ├─ 319
┃                 ┃  ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃  ┃     │   pc: PC_CELL:Int
┃                 ┃  ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃     │
┃                 ┃  ┃  ┃  ┃     ┊  constraint:
┃                 ┃  ┃  ┃  ┃     ┊      false
┃                 ┃  ┃  ┃  ┃     ┊  subst: .Subst
┃                 ┃  ┃  ┃  ┃     └─ 2 (leaf, target)
┃                 ┃  ┃  ┃  ┃         k: K_CELL:K
┃                 ┃  ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃                 ┃  ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃  ┃
┃                 ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃                 ┃  ┃  ┃     ┃ constraint:
┃                 ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                 ┃  ┃  ┃     │
┃                 ┃  ┃  ┃     ├─ 250
┃                 ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃  ┃     │   pc: PC_CELL:Int
┃                 ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃     │
┃                 ┃  ┃  ┃     ┊  constraint:
┃                 ┃  ┃  ┃     ┊      false
┃                 ┃  ┃  ┃     ┊  subst: .Subst
┃                 ┃  ┃  ┃     └─ 2 (leaf, target)
┃                 ┃  ┃  ┃         k: K_CELL:K
┃                 ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃                 ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃  ┃  ┃
┃                 ┃  ┃  ┗━━┓ subst: .Subst
┃                 ┃  ┃     ┃ constraint:
┃                 ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                 ┃  ┃     │
┃                 ┃  ┃     ├─ 197
┃                 ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃  ┃     │   pc: PC_CELL:Int
┃                 ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃  ┃     │
┃                 ┃  ┃     ┊  constraint:
┃                 ┃  ┃     ┊      false
┃                 ┃  ┃     ┊  subst: .Subst
┃                 ┃  ┃     └─ 2 (leaf, target)
┃                 ┃  ┃         k: K_CELL:K
┃                 ┃  ┃         pc: FINAL_PC_CELL:Int
┃                 ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃  ┃
┃                 ┃  ┗━━┓ subst: .Subst
┃                 ┃     ┃ constraint:
┃                 ┃     ┃     W0:Int <=Int BAL:Int
┃                 ┃     │
┃                 ┃     ├─ 155 (split)
┃                 ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃     │   pc: PC_CELL:Int
┃                 ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃
┃                 ┃     ┃ (branch)
┃                 ┃     ┣━━┓ subst: .Subst
┃                 ┃     ┃  ┃ constraint:
┃                 ┃     ┃  ┃     BAL:Int <Int W0:Int
┃                 ┃     ┃  │
┃                 ┃     ┃  ├─ 198
┃                 ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃     ┃  │   pc: PC_CELL:Int
┃                 ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃     ┃  │
┃                 ┃     ┃  ┊  constraint:
┃                 ┃     ┃  ┊      false
┃                 ┃     ┃  ┊  subst: .Subst
┃                 ┃     ┃  └─ 2 (leaf, target)
┃                 ┃     ┃      k: K_CELL:K
┃                 ┃     ┃      pc: FINAL_PC_CELL:Int
┃                 ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃     ┃
┃                 ┃     ┗━━┓ subst: .Subst
┃                 ┃        ┃ constraint: true
┃                 ┃        │
┃                 ┃        ├─ 199 (split)
┃                 ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃        │   pc: PC_CELL:Int
┃                 ┃        │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃        ┃
┃                 ┃        ┃ (branch)
┃                 ┃        ┣━━┓ subst: .Subst
┃                 ┃        ┃  ┃ constraint:
┃                 ┃        ┃  ┃     BAL:Int <Int W0:Int
┃                 ┃        ┃  │
┃                 ┃        ┃  ├─ 255
┃                 ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃        ┃  │   pc: PC_CELL:Int
┃                 ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃        ┃  │
┃                 ┃        ┃  ┊  constraint:
┃                 ┃        ┃  ┊      false
┃                 ┃        ┃  ┊  subst: .Subst
┃                 ┃        ┃  └─ 2 (leaf, target)
┃                 ┃        ┃      k: K_CELL:K
┃                 ┃        ┃      pc: FINAL_PC_CELL:Int
┃                 ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃        ┃
┃                 ┃        ┗━━┓ subst: .Subst
┃                 ┃           ┃ constraint: true
┃                 ┃           │
┃                 ┃           ├─ 256 (split)
┃                 ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃           │   pc: PC_CELL:Int
┃                 ┃           │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃           ┃
┃                 ┃           ┃ (branch)
┃                 ┃           ┣━━┓ subst: .Subst
┃                 ┃           ┃  ┃ constraint:
┃                 ┃           ┃  ┃     BAL:Int <Int W0:Int
┃                 ┃           ┃  │
┃                 ┃           ┃  ├─ 325
┃                 ┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃           ┃  │   pc: PC_CELL:Int
┃                 ┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃           ┃  │
┃                 ┃           ┃  ┊  constraint:
┃                 ┃           ┃  ┊      false
┃                 ┃           ┃  ┊  subst: .Subst
┃                 ┃           ┃  └─ 2 (leaf, target)
┃                 ┃           ┃      k: K_CELL:K
┃                 ┃           ┃      pc: FINAL_PC_CELL:Int
┃                 ┃           ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                 ┃           ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                 ┃           ┃
┃                 ┃           ┗━━┓ subst: .Subst
┃                 ┃              ┃ constraint: true
┃                 ┃              │
┃                 ┃              ├─ 326 (split)
┃                 ┃              │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃              │   pc: PC_CELL:Int
┃                 ┃              │   callDepth: CALLDEPTH_CELL:Int
┃                 ┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃              ┃
┃                 ┃              ┃ (branch)
┃                 ┃              ┣━━┓ subst: .Subst
┃                 ┃              ┃  ┃ constraint:
┃                 ┃              ┃  ┃     BAL:Int <Int W0:Int
┃                 ┃              ┃  │
┃                 ┃              ┃  └─ 421 (leaf, pending)
┃                 ┃              ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃              ┃      pc: PC_CELL:Int
┃                 ┃              ┃      callDepth: CALLDEPTH_CELL:Int
┃                 ┃              ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃              ┃
┃                 ┃              ┗━━┓ subst: .Subst
┃                 ┃                 ┃ constraint: true
┃                 ┃                 │
┃                 ┃                 └─ 422 (leaf, pending)
┃                 ┃                     k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                 ┃                     pc: PC_CELL:Int
┃                 ┃                     callDepth: CALLDEPTH_CELL:Int
┃                 ┃                     statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃
┃                 ┗━━┓ subst: .Subst
┃                    ┃ constraint: true
┃                    │
┃                    ├─ 87 (split)
┃                    │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                    │   pc: PC_CELL:Int
┃                    │   callDepth: CALLDEPTH_CELL:Int
┃                    │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃
┃                    ┃ (branch)
┃                    ┣━━┓ subst: .Subst
┃                    ┃  ┃ constraint:
┃                    ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                    ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                    ┃  │
┃                    ┃  ├─ 116
┃                    ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                    ┃  │   pc: PC_CELL:Int
┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  │
┃                    ┃  │  (3 steps)
┃                    ┃  ├─ 159 (split)
┃                    ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                    ┃  │   pc: PC_CELL:Int
┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃
┃                    ┃  ┃ (branch)
┃                    ┃  ┣━━┓ subst: .Subst
┃                    ┃  ┃  ┃ constraint:
┃                    ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃                    ┃  ┃  │
┃                    ┃  ┃  ├─ 201
┃                    ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                    ┃  ┃  │   pc: PC_CELL:Int
┃                    ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  │
┃                    ┃  ┃  │  (13 steps)
┃                    ┃  ┃  ├─ 329
┃                    ┃  ┃  │   k: K_CELL:K
┃                    ┃  ┃  │   pc: ( PC_CELL:Int +Int 1 )
┃                    ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  │   statusCode: EVMC_BALANCE_UNDERFLOW
┃                    ┃  ┃  │
┃                    ┃  ┃  ┊  constraint:
┃                    ┃  ┃  ┊      ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃                    ┃  ┃  ┊  subst: ...
┃                    ┃  ┃  └─ 2 (leaf, target)
┃                    ┃  ┃      k: K_CELL:K
┃                    ┃  ┃      pc: FINAL_PC_CELL:Int
┃                    ┃  ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                    ┃  ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                    ┃  ┃
┃                    ┃  ┗━━┓ subst: .Subst
┃                    ┃     ┃ constraint:
┃                    ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃                    ┃     │
┃                    ┃     ├─ 202
┃                    ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                    ┃     │   pc: PC_CELL:Int
┃                    ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃     │
┃                    ┃     │  (1 step)
┃                    ┃     ├─ 257 (split)
┃                    ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                    ┃     │   pc: PC_CELL:Int
┃                    ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃     ┃
┃                    ┃     ┃ (branch)
┃                    ┃     ┣━━┓ subst: .Subst
┃                    ┃     ┃  ┃ constraint:
┃                    ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃                    ┃     ┃  │
┃                    ┃     ┃  ├─ 327
┃                    ┃     ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                    ┃     ┃  │   pc: PC_CELL:Int
┃                    ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃     ┃  │
┃                    ┃     ┃  │  (1 step)
┃                    ┃     ┃  └─ 423 (leaf, pending)
┃                    ┃     ┃      k: #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int  ...
┃                    ┃     ┃      pc: PC_CELL:Int
┃                    ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃                    ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃     ┃
┃                    ┃     ┗━━┓ subst: .Subst
┃                    ┃        ┃ constraint:
┃                    ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃                    ┃        │
┃                    ┃        └─ 328 (leaf, pending)
┃                    ┃            k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                    ┃            pc: PC_CELL:Int
┃                    ┃            callDepth: CALLDEPTH_CELL:Int
┃                    ┃            statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃
┃                    ┣━━┓ subst: .Subst
┃                    ┃  ┃ constraint:
┃                    ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                    ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                    ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                    ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                    ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                    ┃  │
┃                    ┃  ├─ 117
┃                    ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                    ┃  │   pc: PC_CELL:Int
┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  │
┃                    ┃  │  (3 steps)
┃                    ┃  ├─ 160 (split)
┃                    ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  │   pc: PC_CELL:Int
┃                    ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃
┃                    ┃  ┃ (branch)
┃                    ┃  ┣━━┓ subst: .Subst
┃                    ┃  ┃  ┃ constraint:
┃                    ┃  ┃  ┃     BAL:Int <Int W0:Int
┃                    ┃  ┃  │
┃                    ┃  ┃  ├─ 204 (split)
┃                    ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃  │   pc: PC_CELL:Int
┃                    ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃
┃                    ┃  ┃  ┃ (branch)
┃                    ┃  ┃  ┣━━┓ subst: .Subst
┃                    ┃  ┃  ┃  ┃ constraint: true
┃                    ┃  ┃  ┃  │
┃                    ┃  ┃  ┃  ├─ 258 (split)
┃                    ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃  ┃  │   pc: PC_CELL:Int
┃                    ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃  ┃
┃                    ┃  ┃  ┃  ┃ (branch)
┃                    ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃                    ┃  ┃  ┃  ┃  ┃ constraint: true
┃                    ┃  ┃  ┃  ┃  │
┃                    ┃  ┃  ┃  ┃  ├─ 330 (split)
┃                    ┃  ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃                    ┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃  ┃  ┃
┃                    ┃  ┃  ┃  ┃  ┃ (branch)
┃                    ┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃                    ┃  ┃  ┃  ┃  ┃  ┃ constraint: true
┃                    ┃  ┃  ┃  ┃  ┃  │
┃                    ┃  ┃  ┃  ┃  ┃  └─ 425 (leaf, pending)
┃                    ┃  ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃                    ┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃  ┃  ┃
┃                    ┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃                    ┃  ┃  ┃  ┃     ┃ constraint:
┃                    ┃  ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                    ┃  ┃  ┃  ┃     │
┃                    ┃  ┃  ┃  ┃     └─ 426 (leaf, pending)
┃                    ┃  ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃                    ┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃  ┃
┃                    ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃                    ┃  ┃  ┃     ┃ constraint:
┃                    ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                    ┃  ┃  ┃     │
┃                    ┃  ┃  ┃     ├─ 331
┃                    ┃  ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃  ┃     │   pc: PC_CELL:Int
┃                    ┃  ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃     │
┃                    ┃  ┃  ┃     ┊  constraint:
┃                    ┃  ┃  ┃     ┊      false
┃                    ┃  ┃  ┃     ┊  subst: .Subst
┃                    ┃  ┃  ┃     └─ 2 (leaf, target)
┃                    ┃  ┃  ┃         k: K_CELL:K
┃                    ┃  ┃  ┃         pc: FINAL_PC_CELL:Int
┃                    ┃  ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃                    ┃  ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                    ┃  ┃  ┃
┃                    ┃  ┃  ┗━━┓ subst: .Subst
┃                    ┃  ┃     ┃ constraint:
┃                    ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                    ┃  ┃     │
┃                    ┃  ┃     ├─ 259
┃                    ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃  ┃     │   pc: PC_CELL:Int
┃                    ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃  ┃     │
┃                    ┃  ┃     ┊  constraint:
┃                    ┃  ┃     ┊      false
┃                    ┃  ┃     ┊  subst: .Subst
┃                    ┃  ┃     └─ 2 (leaf, target)
┃                    ┃  ┃         k: K_CELL:K
┃                    ┃  ┃         pc: FINAL_PC_CELL:Int
┃                    ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃                    ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                    ┃  ┃
┃                    ┃  ┗━━┓ subst: .Subst
┃                    ┃     ┃ constraint:
┃                    ┃     ┃     W0:Int <=Int BAL:Int
┃                    ┃     │
┃                    ┃     ├─ 205 (split)
┃                    ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃     │   pc: PC_CELL:Int
┃                    ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃     ┃
┃                    ┃     ┃ (branch)
┃                    ┃     ┣━━┓ subst: .Subst
┃                    ┃     ┃  ┃ constraint:
┃                    ┃     ┃  ┃     BAL:Int <Int W0:Int
┃                    ┃     ┃  │
┃                    ┃     ┃  ├─ 266
┃                    ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃     ┃  │   pc: PC_CELL:Int
┃                    ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃     ┃  │
┃                    ┃     ┃  ┊  constraint:
┃                    ┃     ┃  ┊      false
┃                    ┃     ┃  ┊  subst: .Subst
┃                    ┃     ┃  └─ 2 (leaf, target)
┃                    ┃     ┃      k: K_CELL:K
┃                    ┃     ┃      pc: FINAL_PC_CELL:Int
┃                    ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                    ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                    ┃     ┃
┃                    ┃     ┗━━┓ subst: .Subst
┃                    ┃        ┃ constraint: true
┃                    ┃        │
┃                    ┃        ├─ 267 (split)
┃                    ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃        │   pc: PC_CELL:Int
┃                    ┃        │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃        ┃
┃                    ┃        ┃ (branch)
┃                    ┃        ┣━━┓ subst: .Subst
┃                    ┃        ┃  ┃ constraint:
┃                    ┃        ┃  ┃     BAL:Int <Int W0:Int
┃                    ┃        ┃  │
┃                    ┃        ┃  ├─ 337
┃                    ┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃        ┃  │   pc: PC_CELL:Int
┃                    ┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃        ┃  │
┃                    ┃        ┃  ┊  constraint:
┃                    ┃        ┃  ┊      false
┃                    ┃        ┃  ┊  subst: .Subst
┃                    ┃        ┃  └─ 2 (leaf, target)
┃                    ┃        ┃      k: K_CELL:K
┃                    ┃        ┃      pc: FINAL_PC_CELL:Int
┃                    ┃        ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                    ┃        ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                    ┃        ┃
┃                    ┃        ┗━━┓ subst: .Subst
┃                    ┃           ┃ constraint: true
┃                    ┃           │
┃                    ┃           ├─ 338 (split)
┃                    ┃           │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃           │   pc: PC_CELL:Int
┃                    ┃           │   callDepth: CALLDEPTH_CELL:Int
┃                    ┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃           ┃
┃                    ┃           ┃ (branch)
┃                    ┃           ┣━━┓ subst: .Subst
┃                    ┃           ┃  ┃ constraint:
┃                    ┃           ┃  ┃     BAL:Int <Int W0:Int
┃                    ┃           ┃  │
┃                    ┃           ┃  └─ 432 (leaf, pending)
┃                    ┃           ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃           ┃      pc: PC_CELL:Int
┃                    ┃           ┃      callDepth: CALLDEPTH_CELL:Int
┃                    ┃           ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃           ┃
┃                    ┃           ┗━━┓ subst: .Subst
┃                    ┃              ┃ constraint: true
┃                    ┃              │
┃                    ┃              └─ 433 (leaf, pending)
┃                    ┃                  k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                    ┃                  pc: PC_CELL:Int
┃                    ┃                  callDepth: CALLDEPTH_CELL:Int
┃                    ┃                  statusCode: STATUSCODE_CELL:StatusCode
┃                    ┃
┃                    ┗━━┓ subst: .Subst
┃                       ┃ constraint: true
┃                       │
┃                       ├─ 118 (split)
┃                       │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                       │   pc: PC_CELL:Int
┃                       │   callDepth: CALLDEPTH_CELL:Int
┃                       │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃
┃                       ┃ (branch)
┃                       ┣━━┓ subst: .Subst
┃                       ┃  ┃ constraint:
┃                       ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                       ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                       ┃  │
┃                       ┃  ├─ 161
┃                       ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                       ┃  │   pc: PC_CELL:Int
┃                       ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  │
┃                       ┃  │  (3 steps)
┃                       ┃  ├─ 206 (split)
┃                       ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                       ┃  │   pc: PC_CELL:Int
┃                       ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃
┃                       ┃  ┃ (branch)
┃                       ┃  ┣━━┓ subst: .Subst
┃                       ┃  ┃  ┃ constraint:
┃                       ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃                       ┃  ┃  │
┃                       ┃  ┃  ├─ 261
┃                       ┃  ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                       ┃  ┃  │   pc: PC_CELL:Int
┃                       ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃  │
┃                       ┃  ┃  │  (13 steps)
┃                       ┃  ┃  └─ 416 (leaf, pending)
┃                       ┃  ┃      k: K_CELL:K
┃                       ┃  ┃      pc: ( PC_CELL:Int +Int 1 )
┃                       ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃      statusCode: EVMC_BALANCE_UNDERFLOW
┃                       ┃  ┃
┃                       ┃  ┗━━┓ subst: .Subst
┃                       ┃     ┃ constraint:
┃                       ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃                       ┃     │
┃                       ┃     ├─ 262
┃                       ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                       ┃     │   pc: PC_CELL:Int
┃                       ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃     │
┃                       ┃     │  (1 step)
┃                       ┃     ├─ 332 (split)
┃                       ┃     │   k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                       ┃     │   pc: PC_CELL:Int
┃                       ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃     ┃
┃                       ┃     ┃ (branch)
┃                       ┃     ┣━━┓ subst: .Subst
┃                       ┃     ┃  ┃ constraint:
┃                       ┃     ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃                       ┃     ┃  │
┃                       ┃     ┃  └─ 430 (leaf, pending)
┃                       ┃     ┃      k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                       ┃     ┃      pc: PC_CELL:Int
┃                       ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃                       ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃     ┃
┃                       ┃     ┗━━┓ subst: .Subst
┃                       ┃        ┃ constraint:
┃                       ┃        ┃     1024 <=Int CALLDEPTH_CELL:Int
┃                       ┃        │
┃                       ┃        └─ 431 (leaf, pending)
┃                       ┃            k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                       ┃            pc: PC_CELL:Int
┃                       ┃            callDepth: CALLDEPTH_CELL:Int
┃                       ┃            statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃
┃                       ┣━━┓ subst: .Subst
┃                       ┃  ┃ constraint:
┃                       ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                       ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                       ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                       ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                       ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                       ┃  │
┃                       ┃  ├─ 162
┃                       ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                       ┃  │   pc: PC_CELL:Int
┃                       ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  │
┃                       ┃  │  (3 steps)
┃                       ┃  ├─ 207 (split)
┃                       ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃  │   pc: PC_CELL:Int
┃                       ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃
┃                       ┃  ┃ (branch)
┃                       ┃  ┣━━┓ subst: .Subst
┃                       ┃  ┃  ┃ constraint:
┃                       ┃  ┃  ┃     BAL:Int <Int W0:Int
┃                       ┃  ┃  │
┃                       ┃  ┃  ├─ 263 (split)
┃                       ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃  ┃  │   pc: PC_CELL:Int
┃                       ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃  ┃
┃                       ┃  ┃  ┃ (branch)
┃                       ┃  ┃  ┣━━┓ subst: .Subst
┃                       ┃  ┃  ┃  ┃ constraint: true
┃                       ┃  ┃  ┃  │
┃                       ┃  ┃  ┃  ├─ 333 (split)
┃                       ┃  ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃  ┃  ┃  │   pc: PC_CELL:Int
┃                       ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃  ┃  ┃
┃                       ┃  ┃  ┃  ┃ (branch)
┃                       ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃                       ┃  ┃  ┃  ┃  ┃ constraint: true
┃                       ┃  ┃  ┃  ┃  │
┃                       ┃  ┃  ┃  ┃  └─ 428 (leaf, pending)
┃                       ┃  ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃                       ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃  ┃  ┃
┃                       ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃                       ┃  ┃  ┃     ┃ constraint:
┃                       ┃  ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                       ┃  ┃  ┃     │
┃                       ┃  ┃  ┃     └─ 429 (leaf, pending)
┃                       ┃  ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃  ┃  ┃         pc: PC_CELL:Int
┃                       ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃  ┃
┃                       ┃  ┃  ┗━━┓ subst: .Subst
┃                       ┃  ┃     ┃ constraint:
┃                       ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                       ┃  ┃     │
┃                       ┃  ┃     ├─ 334
┃                       ┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃  ┃     │   pc: PC_CELL:Int
┃                       ┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃  ┃     │
┃                       ┃  ┃     ┊  constraint:
┃                       ┃  ┃     ┊      false
┃                       ┃  ┃     ┊  subst: .Subst
┃                       ┃  ┃     └─ 2 (leaf, target)
┃                       ┃  ┃         k: K_CELL:K
┃                       ┃  ┃         pc: FINAL_PC_CELL:Int
┃                       ┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃                       ┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                       ┃  ┃
┃                       ┃  ┗━━┓ subst: .Subst
┃                       ┃     ┃ constraint:
┃                       ┃     ┃     W0:Int <=Int BAL:Int
┃                       ┃     │
┃                       ┃     ├─ 264 (split)
┃                       ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃     │   pc: PC_CELL:Int
┃                       ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃     ┃
┃                       ┃     ┃ (branch)
┃                       ┃     ┣━━┓ subst: .Subst
┃                       ┃     ┃  ┃ constraint:
┃                       ┃     ┃  ┃     BAL:Int <Int W0:Int
┃                       ┃     ┃  │
┃                       ┃     ┃  ├─ 335
┃                       ┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃     ┃  │   pc: PC_CELL:Int
┃                       ┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃     ┃  │
┃                       ┃     ┃  ┊  constraint:
┃                       ┃     ┃  ┊      false
┃                       ┃     ┃  ┊  subst: .Subst
┃                       ┃     ┃  └─ 2 (leaf, target)
┃                       ┃     ┃      k: K_CELL:K
┃                       ┃     ┃      pc: FINAL_PC_CELL:Int
┃                       ┃     ┃      callDepth: FINAL_CALLDEPTH_CELL:Int
┃                       ┃     ┃      statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃                       ┃     ┃
┃                       ┃     ┗━━┓ subst: .Subst
┃                       ┃        ┃ constraint: true
┃                       ┃        │
┃                       ┃        ├─ 336 (split)
┃                       ┃        │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃        │   pc: PC_CELL:Int
┃                       ┃        │   callDepth: CALLDEPTH_CELL:Int
┃                       ┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃        ┃
┃                       ┃        ┃ (branch)
┃                       ┃        ┣━━┓ subst: .Subst
┃                       ┃        ┃  ┃ constraint:
┃                       ┃        ┃  ┃     BAL:Int <Int W0:Int
┃                       ┃        ┃  │
┃                       ┃        ┃  └─ 434 (leaf, pending)
┃                       ┃        ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃        ┃      pc: PC_CELL:Int
┃                       ┃        ┃      callDepth: CALLDEPTH_CELL:Int
┃                       ┃        ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃        ┃
┃                       ┃        ┗━━┓ subst: .Subst
┃                       ┃           ┃ constraint: true
┃                       ┃           │
┃                       ┃           └─ 435 (leaf, pending)
┃                       ┃               k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                       ┃               pc: PC_CELL:Int
┃                       ┃               callDepth: CALLDEPTH_CELL:Int
┃                       ┃               statusCode: STATUSCODE_CELL:StatusCode
┃                       ┃
┃                       ┗━━┓ subst: .Subst
┃                          ┃ constraint: true
┃                          │
┃                          ├─ 163 (split)
┃                          │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                          │   pc: PC_CELL:Int
┃                          │   callDepth: CALLDEPTH_CELL:Int
┃                          │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃
┃                          ┃ (branch)
┃                          ┣━━┓ subst: .Subst
┃                          ┃  ┃ constraint:
┃                          ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                          ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                          ┃  │
┃                          ┃  ├─ 208
┃                          ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                          ┃  │   pc: PC_CELL:Int
┃                          ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  │
┃                          ┃  │  (3 steps)
┃                          ┃  ├─ 268 (split)
┃                          ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                          ┃  │   pc: PC_CELL:Int
┃                          ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  ┃
┃                          ┃  ┃ (branch)
┃                          ┃  ┣━━┓ subst: .Subst
┃                          ┃  ┃  ┃ constraint:
┃                          ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃                          ┃  ┃  │
┃                          ┃  ┃  └─ 339 (leaf, pending)
┃                          ┃  ┃      k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                          ┃  ┃      pc: PC_CELL:Int
┃                          ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                          ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  ┃
┃                          ┃  ┗━━┓ subst: .Subst
┃                          ┃     ┃ constraint:
┃                          ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃                          ┃     │
┃                          ┃     ├─ 340
┃                          ┃     │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                          ┃     │   pc: PC_CELL:Int
┃                          ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃     │
┃                          ┃     │  (1 step)
┃                          ┃     └─ 436 (leaf, pending)
┃                          ┃         k: #checkDepthExceeded ~> #checkNonceExceeded WO:Int ~> #create WO:Int #newAddr ( W ...
┃                          ┃         pc: PC_CELL:Int
┃                          ┃         callDepth: CALLDEPTH_CELL:Int
┃                          ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃
┃                          ┣━━┓ subst: .Subst
┃                          ┃  ┃ constraint:
┃                          ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                          ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                          ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                          ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                          ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                          ┃  │
┃                          ┃  ├─ 209
┃                          ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                          ┃  │   pc: PC_CELL:Int
┃                          ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  │
┃                          ┃  │  (3 steps)
┃                          ┃  ├─ 272 (split)
┃                          ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃  │   pc: PC_CELL:Int
┃                          ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  ┃
┃                          ┃  ┃ (branch)
┃                          ┃  ┣━━┓ subst: .Subst
┃                          ┃  ┃  ┃ constraint:
┃                          ┃  ┃  ┃     BAL:Int <Int W0:Int
┃                          ┃  ┃  │
┃                          ┃  ┃  ├─ 346 (split)
┃                          ┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃  ┃  │   pc: PC_CELL:Int
┃                          ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  ┃  ┃
┃                          ┃  ┃  ┃ (branch)
┃                          ┃  ┃  ┣━━┓ subst: .Subst
┃                          ┃  ┃  ┃  ┃ constraint: true
┃                          ┃  ┃  ┃  │
┃                          ┃  ┃  ┃  └─ 448 (leaf, pending)
┃                          ┃  ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃  ┃  ┃      pc: PC_CELL:Int
┃                          ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                          ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  ┃  ┃
┃                          ┃  ┃  ┗━━┓ subst: .Subst
┃                          ┃  ┃     ┃ constraint:
┃                          ┃  ┃     ┃     W0:Int <=Int BAL:Int
┃                          ┃  ┃     │
┃                          ┃  ┃     └─ 449 (leaf, pending)
┃                          ┃  ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃  ┃         pc: PC_CELL:Int
┃                          ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃                          ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃  ┃
┃                          ┃  ┗━━┓ subst: .Subst
┃                          ┃     ┃ constraint:
┃                          ┃     ┃     W0:Int <=Int BAL:Int
┃                          ┃     │
┃                          ┃     ├─ 347 (split)
┃                          ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃     │   pc: PC_CELL:Int
┃                          ┃     │   callDepth: CALLDEPTH_CELL:Int
┃                          ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃     ┃
┃                          ┃     ┃ (branch)
┃                          ┃     ┣━━┓ subst: .Subst
┃                          ┃     ┃  ┃ constraint:
┃                          ┃     ┃  ┃     BAL:Int <Int W0:Int
┃                          ┃     ┃  │
┃                          ┃     ┃  └─ 450 (leaf, pending)
┃                          ┃     ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃     ┃      pc: PC_CELL:Int
┃                          ┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃                          ┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃     ┃
┃                          ┃     ┗━━┓ subst: .Subst
┃                          ┃        ┃ constraint: true
┃                          ┃        │
┃                          ┃        └─ 451 (leaf, pending)
┃                          ┃            k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                          ┃            pc: PC_CELL:Int
┃                          ┃            callDepth: CALLDEPTH_CELL:Int
┃                          ┃            statusCode: STATUSCODE_CELL:StatusCode
┃                          ┃
┃                          ┗━━┓ subst: .Subst
┃                             ┃ constraint: true
┃                             │
┃                             ├─ 210 (split)
┃                             │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                             │   pc: PC_CELL:Int
┃                             │   callDepth: CALLDEPTH_CELL:Int
┃                             │   statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃
┃                             ┃ (branch)
┃                             ┣━━┓ subst: .Subst
┃                             ┃  ┃ constraint:
┃                             ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                             ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                             ┃  │
┃                             ┃  ├─ 273
┃                             ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                             ┃  │   pc: PC_CELL:Int
┃                             ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                             ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃  │
┃                             ┃  │  (3 steps)
┃                             ┃  ├─ 349 (split)
┃                             ┃  │   k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                             ┃  │   pc: PC_CELL:Int
┃                             ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                             ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃  ┃
┃                             ┃  ┃ (branch)
┃                             ┃  ┣━━┓ subst: .Subst
┃                             ┃  ┃  ┃ constraint:
┃                             ┃  ┃  ┃     BALANCE_CELL:Int <Int W0:Int
┃                             ┃  ┃  │
┃                             ┃  ┃  └─ 452 (leaf, pending)
┃                             ┃  ┃      k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                             ┃  ┃      pc: PC_CELL:Int
┃                             ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                             ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃  ┃
┃                             ┃  ┗━━┓ subst: .Subst
┃                             ┃     ┃ constraint:
┃                             ┃     ┃     W0:Int <=Int BALANCE_CELL:Int
┃                             ┃     │
┃                             ┃     └─ 453 (leaf, pending)
┃                             ┃         k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                             ┃         pc: PC_CELL:Int
┃                             ┃         callDepth: CALLDEPTH_CELL:Int
┃                             ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃
┃                             ┣━━┓ subst: .Subst
┃                             ┃  ┃ constraint:
┃                             ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                             ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                             ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                             ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                             ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                             ┃  │
┃                             ┃  ├─ 274
┃                             ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                             ┃  │   pc: PC_CELL:Int
┃                             ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                             ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃  │
┃                             ┃  │  (3 steps)
┃                             ┃  ├─ 350 (split)
┃                             ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                             ┃  │   pc: PC_CELL:Int
┃                             ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                             ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃  ┃
┃                             ┃  ┃ (branch)
┃                             ┃  ┣━━┓ subst: .Subst
┃                             ┃  ┃  ┃ constraint:
┃                             ┃  ┃  ┃     BAL:Int <Int W0:Int
┃                             ┃  ┃  │
┃                             ┃  ┃  └─ 455 (leaf, pending)
┃                             ┃  ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                             ┃  ┃      pc: PC_CELL:Int
┃                             ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃                             ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃  ┃
┃                             ┃  ┗━━┓ subst: .Subst
┃                             ┃     ┃ constraint:
┃                             ┃     ┃     W0:Int <=Int BAL:Int
┃                             ┃     │
┃                             ┃     └─ 456 (leaf, pending)
┃                             ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                             ┃         pc: PC_CELL:Int
┃                             ┃         callDepth: CALLDEPTH_CELL:Int
┃                             ┃         statusCode: STATUSCODE_CELL:StatusCode
┃                             ┃
┃                             ┗━━┓ subst: .Subst
┃                                ┃ constraint: true
┃                                │
┃                                ├─ 275 (split)
┃                                │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                │   pc: PC_CELL:Int
┃                                │   callDepth: CALLDEPTH_CELL:Int
┃                                │   statusCode: STATUSCODE_CELL:StatusCode
┃                                ┃
┃                                ┃ (branch)
┃                                ┣━━┓ subst: .Subst
┃                                ┃  ┃ constraint:
┃                                ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                                ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                                ┃  │
┃                                ┃  ├─ 354
┃                                ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                ┃  │   pc: PC_CELL:Int
┃                                ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                                ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                                ┃  │
┃                                ┃  │  (3 steps)
┃                                ┃  └─ 461 (leaf, pending)
┃                                ┃      k: #checkBalanceUnderflow WO:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceExceed ...
┃                                ┃      pc: PC_CELL:Int
┃                                ┃      callDepth: CALLDEPTH_CELL:Int
┃                                ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                                ┃
┃                                ┣━━┓ subst: .Subst
┃                                ┃  ┃ constraint:
┃                                ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                                ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                                ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                                ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                                ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                                ┃  │
┃                                ┃  ├─ 355
┃                                ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                ┃  │   pc: PC_CELL:Int
┃                                ┃  │   callDepth: CALLDEPTH_CELL:Int
┃                                ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃                                ┃  │
┃                                ┃  │  (3 steps)
┃                                ┃  └─ 462 (leaf, pending)
┃                                ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃                                ┃      pc: PC_CELL:Int
┃                                ┃      callDepth: CALLDEPTH_CELL:Int
┃                                ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                                ┃
┃                                ┗━━┓ subst: .Subst
┃                                   ┃ constraint: true
┃                                   │
┃                                   ├─ 356 (split)
┃                                   │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                   │   pc: PC_CELL:Int
┃                                   │   callDepth: CALLDEPTH_CELL:Int
┃                                   │   statusCode: STATUSCODE_CELL:StatusCode
┃                                   ┃
┃                                   ┃ (branch)
┃                                   ┣━━┓ subst: .Subst
┃                                   ┃  ┃ constraint:
┃                                   ┃  ┃     ID_CELL:Int ==Int WO:Int
┃                                   ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                                   ┃  │
┃                                   ┃  └─ 466 (leaf, pending)
┃                                   ┃      k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                   ┃      pc: PC_CELL:Int
┃                                   ┃      callDepth: CALLDEPTH_CELL:Int
┃                                   ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                                   ┃
┃                                   ┣━━┓ subst: .Subst
┃                                   ┃  ┃ constraint:
┃                                   ┃  ┃     ( notBool ID_CELL:Int ==Int WO:Int )
┃                                   ┃  ┃     ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                                   ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃                                   ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                                   ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃                                   ┃  │
┃                                   ┃  └─ 467 (leaf, pending)
┃                                   ┃      k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                   ┃      pc: PC_CELL:Int
┃                                   ┃      callDepth: CALLDEPTH_CELL:Int
┃                                   ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                                   ┃
┃                                   ┗━━┓ subst: .Subst
┃                                      ┃ constraint: true
┃                                      │
┃                                      └─ 468 (leaf, pending)
┃                                          k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                                          pc: PC_CELL:Int
┃                                          callDepth: CALLDEPTH_CELL:Int
┃                                          statusCode: STATUSCODE_CELL:StatusCode
┃
┗━━┓ subst: .Subst
   ┃ constraint:
   ┃     STATIC_CELL:Bool
   │
   ├─ 4
   │   k: #next [ CREATE ] ~> K_CELL:K
   │   pc: PC_CELL:Int
   │   callDepth: CALLDEPTH_CELL:Int
   │   statusCode: STATUSCODE_CELL:StatusCode
   │
   │  (2 steps)
   └─ 6 (leaf, terminal)
       k: #halt ~> K_CELL:K
       pc: PC_CELL:Int
       callDepth: CALLDEPTH_CELL:Int
       statusCode: EVMC_STATIC_MODE_VIOLATION



Node 1:

( <generatedTop>
  <kevm>
    <k>
      #next [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { false #Equals <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } ) )



Node 2:

...



Node 3:

( <generatedTop>
  <kevm>
    <k>
      #next [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { STATIC_CELL:Bool #Equals false }
#And ( { false #Equals <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } ) ) )



Node 4:

( <generatedTop>
  <kevm>
    <k>
      #next [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { STATIC_CELL:Bool #Equals true }
#And ( { false #Equals <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } ) ) )



Node 5:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 6:

( <generatedTop>
  <kevm>
    <k>
      #halt
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <statusCode>
          EVMC_STATIC_MODE_VIOLATION
        </statusCode>
        <callState>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          <static>
            true
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals STATIC_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 7:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 8:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 9:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 10:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 11:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 12:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 13:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 14:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 15:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 16:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 17:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 18:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 19:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 20:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 21:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 22:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 23:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 24:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 25:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 26:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 27:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 28:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 29:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 30:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 31:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 32:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 33:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 34:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 35:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 36:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 37:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 38:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 39:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 40:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 41:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 42:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 43:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 44:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 45:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 46:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 47:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 48:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 49:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 50:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 51:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 52:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 53:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 54:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 55:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 56:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 57:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 58:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 59:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 60:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 61:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 62:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 63:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 64:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 65:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 66:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 67:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 68:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 69:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 70:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 71:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 72:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 73:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 74:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 75:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 76:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 77:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 78:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 79:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 80:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 81:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 82:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 83:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 84:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 85:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 86:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 87:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 88:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 89:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 90:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 91:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 92:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 93:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 94:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 95:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 96:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 97:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 98:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 99:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 100:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 101:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 102:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 103:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 104:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 105:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 106:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 107:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 108:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 109:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 110:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 111:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 112:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 113:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 114:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 115:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 116:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 117:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 118:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 119:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 120:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 121:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 122:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_CALL_DEPTH_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 123:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_CALL_DEPTH_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 124:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 125:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 126:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 127:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 128:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 129:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 130:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 131:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 132:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 133:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 134:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 135:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 136:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 137:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 138:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 139:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 140:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 141:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 142:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 143:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 144:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 145:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 146:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 147:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 148:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 149:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 150:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 151:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 152:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 153:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 154:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 155:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 156:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_NONCE_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool #rangeNonce ( NONCE_CELL:Int ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 157:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 158:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 159:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 160:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 161:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 162:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 163:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 164:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 165:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 166:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 167:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 168:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 169:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 170:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 171:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 172:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 173:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 174:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 175:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 176:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 177:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 178:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 179:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 180:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 181:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 182:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 183:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 184:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 185:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 186:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 187:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 188:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 189:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 190:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 191:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 192:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 193:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 194:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 195:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 196:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 197:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 198:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 199:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 200:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 201:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 202:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 203:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_CALL_DEPTH_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 204:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 205:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 206:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 207:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 208:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 209:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 210:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 211:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 212:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 213:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 214:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 215:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 216:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 217:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 218:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_NONCE_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool #rangeNonce ( NONCE_CELL:Int ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 219:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 220:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 221:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 222:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 223:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 224:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 225:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 226:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 227:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 228:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 229:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 230:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 231:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 232:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 233:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 234:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 235:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 236:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 237:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 238:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 239:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 240:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 241:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 242:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 243:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 244:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 245:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 246:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 247:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 248:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 249:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 250:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 251:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_CALL_DEPTH_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 252:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 253:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 254:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 255:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 256:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 257:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 258:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 259:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 260:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 261:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 262:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 263:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 264:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 265:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_NONCE_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool #rangeNonce ( NONCE_CELL:Int ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 266:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 267:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 268:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 269:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 270:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 271:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 272:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 273:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 274:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 275:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 276:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 277:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 278:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 279:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 280:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 281:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 282:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE0:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE0:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE0:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE0:Int } ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE0:AccountCode #Equals CODE:Bytes }
#And ( { NONCE0:Int #Equals 0 }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 283:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE0:AccountCode . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE0:AccountCode . #Exists NONCE0:Int . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen6:Map . #Exists CODE0:Bytes . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen6:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 284:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 285:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 286:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 287:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 288:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 289:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 290:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 291:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 292:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 293:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 294:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 295:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 296:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 297:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 298:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 299:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 300:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 301:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 302:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 303:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 304:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 305:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 306:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 307:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 308:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 309:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 310:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 311:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 312:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 313:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 314:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 315:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 316:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 317:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 318:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 319:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 320:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_CALL_DEPTH_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 321:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 322:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 323:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 324:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 325:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 326:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 327:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 328:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 329:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 330:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 331:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 332:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 333:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 334:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 335:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 336:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 337:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 338:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 339:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 340:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 341:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 342:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_NONCE_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool #rangeNonce ( NONCE_CELL:Int ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 343:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 344:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE0:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE0:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE0:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE0:Int } ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE0:AccountCode #Equals CODE:Bytes }
#And ( { NONCE0:Int #Equals 0 }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 345:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE0:AccountCode . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE0:AccountCode . #Exists NONCE0:Int . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen6:Map . #Exists CODE0:Bytes . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen6:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 346:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 347:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 348:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 349:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 350:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 351:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 352:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 353:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 354:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 355:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 356:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 357:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 358:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 359:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 360:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 361:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 362:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_CALL_DEPTH_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 363:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE1:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE1:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE1:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen6:Map #Equals _Gen9:Map }
#And { CODE0:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE1:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 364:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE1:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE1:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE1:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE1:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE1:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE1:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE1:Int } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals NONCE1:Int } ) )
#And ( #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE1:AccountCode #Equals CODE:Bytes }
#And ( { NONCE1:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE1:AccountCode #Equals CODE0:Bytes }
#And ( { NONCE1:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 365:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE1:AccountCode . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> } ) ) )
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And #Exists CODE1:AccountCode . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE1:AccountCode . #Exists NONCE1:Int . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen9:Map . #Exists CODE1:Bytes . ( { 0 #Equals lengthBytes ( CODE1:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 366:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 367:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 368:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 369:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE0:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE0:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE0:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE0:Int } ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE0:AccountCode #Equals CODE:Bytes }
#And ( { NONCE0:Int #Equals 0 }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 370:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE0:AccountCode . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE0:AccountCode . #Exists NONCE0:Int . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen6:Map . #Exists CODE0:Bytes . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen6:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 371:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_STACK_UNDERFLOW
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals 0 <Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 372:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_STACK_OVERFLOW
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( { true #Equals 0 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) }
#And { true #Equals 1024 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 373:

( <generatedTop>
  <kevm>
    <k>
      #addr [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #exec [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #pc [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) <=Int 0 }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And { true #Equals ( notBool ( 0 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) andBool 1024 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) ) ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 374:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_SUCCESS
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals .NoOpCode ~> .K ==K #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ~> .K }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 375:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { .NoOpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) } ) )
#And ( #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And { true #Equals 0 <Int #stackNeeded ( OP:OpCode ) } ) ) )
#And ( #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And ( { true #Equals ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) >Int 0 }
#And { true #Equals ( 0 +Int ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) ) >Int 1024 } ) ) ) )
#And #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And ( { false #Equals ( ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) >Int 0 andBool ( 0 +Int ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) ) >Int 1024 ) }
#And ( { false #Equals ( false andBool #changesState ( OP:OpCode , .WordStack ) ) }
#And { false #Equals 0 <Int #stackNeeded ( OP:OpCode ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 376:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 377:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 378:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 379:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 380:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 381:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 382:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 383:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 384:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 385:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 386:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 387:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 388:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 389:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 390:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 391:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 392:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 393:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 394:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 395:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 396:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 397:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 398:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 399:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 400:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 401:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 402:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 403:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 404:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 405:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 406:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 407:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 408:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 409:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 410:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 411:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 412:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 413:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 414:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 415:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 416:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_BALANCE_UNDERFLOW
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 417:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 418:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 419:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 420:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 421:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 422:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 423:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 424:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 425:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 426:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 427:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 428:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 429:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 430:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 431:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 432:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 433:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 434:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 435:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 436:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 437:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_STACK_UNDERFLOW
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals 0 <Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 438:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_STACK_OVERFLOW
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( { true #Equals 0 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) }
#And { true #Equals 1024 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 439:

( <generatedTop>
  <kevm>
    <k>
      #addr [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #exec [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #pc [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) <=Int 0 }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And { true #Equals ( notBool ( 0 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) andBool 1024 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) ) ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 440:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_SUCCESS
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals .NoOpCode ~> .K ==K #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ~> .K }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 441:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { .NoOpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) } ) )
#And ( #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And { true #Equals 0 <Int #stackNeeded ( OP:OpCode ) } ) ) )
#And ( #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And ( { true #Equals ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) >Int 0 }
#And { true #Equals ( 0 +Int ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) ) >Int 1024 } ) ) ) )
#And #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And ( { false #Equals ( ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) >Int 0 andBool ( 0 +Int ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) ) >Int 1024 ) }
#And ( { false #Equals ( false andBool #changesState ( OP:OpCode , .WordStack ) ) }
#And { false #Equals 0 <Int #stackNeeded ( OP:OpCode ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 442:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_NONCE_EXCEEDED
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool #rangeNonce ( NONCE_CELL:Int ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 443:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 444:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 445:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE1:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE1:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE1:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen6:Map #Equals _Gen9:Map }
#And { CODE0:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE1:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 446:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE1:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE1:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE1:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE1:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE1:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE1:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE1:Int } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals NONCE1:Int } ) )
#And ( #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE1:AccountCode #Equals CODE:Bytes }
#And ( { NONCE1:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE1:AccountCode #Equals CODE0:Bytes }
#And ( { NONCE1:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 447:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE1:AccountCode . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> } ) ) )
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And #Exists CODE1:AccountCode . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE1:AccountCode . #Exists NONCE1:Int . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen9:Map . #Exists CODE1:Bytes . ( { 0 #Equals lengthBytes ( CODE1:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 448:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 449:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 450:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) )



Node 451:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 452:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 453:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 454:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE0:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE0:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE0:Int } ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE0:AccountCode #Equals CODE:Bytes }
#And ( { NONCE0:Int #Equals 0 }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 455:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BAL:Int <Int W0:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 456:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BAL:Int }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) )



Node 457:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 458:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE0:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE0:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE0:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE0:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE0:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE0:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE0:Int } ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE0:AccountCode #Equals CODE:Bytes }
#And ( { NONCE0:Int #Equals 0 }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 459:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE0:AccountCode . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE0:AccountCode . #Exists NONCE0:Int . ( { true #Equals ( ( notBool CODE0:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen6:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen6:Map . #Exists CODE0:Bytes . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen6:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 460:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 461:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow WO:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded WO:Int
      ~> #create WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            WO:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 462:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            _Gen22:BalanceCell
            _Gen23:CodeCell
            _Gen24:StorageCell
            _Gen25:OrigStorageCell
            _Gen26:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int W0:Int ) }
#And ( { true #Equals ( notBool ID_CELL:Int ==Int WO:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  _Gen22:BalanceCell
  _Gen23:CodeCell
  _Gen24:StorageCell
  _Gen25:OrigStorageCell
  _Gen26:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 463:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 464:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 465:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( #Exists CODE:AccountCode . #Exists NONCE:Int . ( { true #Equals ( ( notBool CODE:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> } ) ) )
#And #Not ( #Exists _Gen6:Map . #Exists _Gen7:Map . #Exists CODE:Bytes . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 466:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 467:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( #Not ( { ID_CELL:Int #Equals WO:Int } )
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ID_CELL:Int
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) )



Node 468:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) ) )



Node 469:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE:Bytes
              </code>
              <storage>
                _Gen6:Map
              </storage>
              <origStorage>
                _Gen7:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen6:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen7:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE:Bytes
  </code>
  <storage>
    _Gen6:Map
  </storage>
  <origStorage>
    _Gen7:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 470:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 471:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) )



Node 472:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { false #Equals <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { WO:Int #Equals #newAddr ( WO:Int , NONCE_CELL:Int ) } )
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) )



Node 473:

( <generatedTop>
  <kevm>
    <k>
      #newAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            DotAccountVar:AccountCellMap )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) )



Node 474:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE1:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE1:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE1:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen6:Map #Equals _Gen9:Map }
#And { CODE0:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE1:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 475:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE2:Bytes
              </code>
              <storage>
                _Gen10:Map
              </storage>
              <origStorage>
                _Gen11:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE2:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE2:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen10:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen11:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE2:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen11:Map }
#And { CODE:Bytes #Equals CODE2:Bytes } ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen6:Map #Equals _Gen11:Map }
#And { CODE0:Bytes #Equals CODE2:Bytes } ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE1:Bytes ) }
#And ( { _Gen9:Map #Equals _Gen11:Map }
#And { CODE1:Bytes #Equals CODE2:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE2:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE2:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals 0 } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE2:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And { NONCE1:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE2:Bytes
  </code>
  <storage>
    _Gen10:Map
  </storage>
  <origStorage>
    _Gen11:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 476:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE2:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE2:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE2:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE2:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE2:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE2:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE2:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE2:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE2:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE2:Int } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals NONCE2:Int } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And { NONCE1:Int #Equals NONCE2:Int } ) )
#And ( #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE2:AccountCode #Equals CODE:Bytes }
#And ( { NONCE2:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And ( #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE2:AccountCode #Equals CODE0:Bytes }
#And ( { NONCE2:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE2:AccountCode #Equals CODE1:Bytes }
#And ( { NONCE2:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE1:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 477:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE2:AccountCode . ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE2:AccountCode
</code> } ) ) )
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And #Exists CODE2:AccountCode . ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE2:AccountCode
</code> } ) ) )
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> }
#And #Exists CODE2:AccountCode . ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE2:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE2:AccountCode . #Exists NONCE2:Int . ( { true #Equals ( ( notBool CODE2:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE2:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE2:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE2:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE1:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen10:Map . #Exists _Gen11:Map . #Exists CODE2:Bytes . ( { 0 #Equals lengthBytes ( CODE2:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE2:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen10:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen11:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 478:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_STACK_UNDERFLOW
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals 0 <Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 479:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_STACK_OVERFLOW
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( { true #Equals 0 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) }
#And { true #Equals 1024 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 480:

( <generatedTop>
  <kevm>
    <k>
      #addr [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #exec [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #pc [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { OP:OpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) }
#And ( { true #Equals #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) <=Int 0 }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And { true #Equals ( notBool ( 0 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) andBool 1024 <Int ( #stackAdded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) -Int #stackNeeded ( #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ) ) ) ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 481:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_SUCCESS
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals .NoOpCode ~> .K ==K #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ~> .K }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 482:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And { .NoOpCode #Equals #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) } ) )
#And ( #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And { true #Equals 0 <Int #stackNeeded ( OP:OpCode ) } ) ) )
#And ( #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And ( { true #Equals ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) >Int 0 }
#And { true #Equals ( 0 +Int ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) ) >Int 1024 } ) ) ) )
#And #Not ( #Exists OP:OpCode . ( #Ceil ( #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) ) )
#And ( { #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) #Equals OP:OpCode }
#And ( { false #Equals ( ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) >Int 0 andBool ( 0 +Int ( #stackAdded ( OP:OpCode ) -Int #stackNeeded ( OP:OpCode ) ) ) >Int 1024 ) }
#And ( { false #Equals ( false andBool #changesState ( OP:OpCode , .WordStack ) ) }
#And { false #Equals 0 <Int #stackNeeded ( OP:OpCode ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 483:

( <generatedTop>
  <kevm>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <statusCode>
          EVMC_ACCOUNT_ALREADY_EXISTS
        </statusCode>
        <callState>
          <id>
            WO:Int
          </id>
          <wordStack>
            ( 0 : WS:WordStack )
          </wordStack>
          <pc>
            ( PC_CELL:Int +Int 1 )
          </pc>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE_CELL:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE_CELL:Int ==Int -1 ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) ) ) ) )



Node 484:

( <generatedTop>
  <kevm>
    <k>
      #next [ #lookupOpCode ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , SCHEDULE_CELL:Schedule ) ]
      ~> #execute
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callStack>
          ListItem ( <callState>
            <id>
              WO:Int
            </id>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <gas>
              GAS_CELL:Gas
            </gas>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
            ...
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              <balance>
                ORIGTO:Int
              </balance>
              <code>
                CODE0:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <touchedAccounts>
          TOUCHEDACCOUNTS_CELL:Set |Set SetItem ( WO:Int ) |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
        </touchedAccounts>
        <callState>
          <program>
            #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
          </program>
          <jumpDests>
            #computeValidJumpDests ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) , 0 , padRightBytes ( b"" , lengthBytes ( #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int ) ) , 0 ) )
          </jumpDests>
          <id>
            #newAddr ( WO:Int , NONCE_CELL:Int )
          </id>
          <caller>
            WO:Int
          </caller>
          <callData>
            b""
          </callData>
          <callValue>
            W0:Int
          </callValue>
          <wordStack>
            .WordStack
          </wordStack>
          <localMem>
            b""
          </localMem>
          <pc>
            0
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            0
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            ( CALLDEPTH_CELL:Int +Int 1 )
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) ) |Set SetItem ( WO:Int )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            <balance>
              chop ( ( ORIGTO:Int +Int W0:Int ) )
            </balance>
            <code>
              CODE0:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              #if Gemptyisnonexistent << SCHEDULE_CELL:Schedule >> #then 1 #else 0 #fi
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              chop ( ( BALANCE_CELL:Int -Int W0:Int ) )
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen0:BalanceCell #Equals <balance>
  ORIGTO:Int
</balance> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE0:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE0:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE0:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  <balance>
    ORIGTO:Int
  </balance>
  <code>
    CODE0:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 485:

( <generatedTop>
  <kevm>
    <k>
      #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE1:Bytes
              </code>
              <storage>
                _Gen8:Map
              </storage>
              <origStorage>
                _Gen9:Map
              </origStorage>
              _Gen4:TransientStorageCell
              <nonce>
                0
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE1:Bytes
            </code>
            <storage>
              .Map
            </storage>
            <origStorage>
              .Map
            </origStorage>
            _Gen4:TransientStorageCell
            <nonce>
              0
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals 0 ==Int lengthBytes ( CODE1:Bytes ) }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And ( { _Gen7:Map #Equals _Gen9:Map }
#And { CODE:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And ( { _Gen6:Map #Equals _Gen9:Map }
#And { CODE0:Bytes #Equals CODE1:Bytes } ) ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals 0 } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:Bytes ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals 0 } ) )
#And { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE1:Bytes
  </code>
  <storage>
    _Gen8:Map
  </storage>
  <origStorage>
    _Gen9:Map
  </origStorage>
  _Gen4:TransientStorageCell
  <nonce>
    0
  </nonce>
</account>
AC1_1:AccountCellMap ) } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 486:

( <generatedTop>
  <kevm>
    <k>
      #end EVMC_ACCOUNT_ALREADY_EXISTS
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              <code>
                CODE1:AccountCode
              </code>
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              <nonce>
                NONCE1:Int
              </nonce>
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            <code>
              CODE1:AccountCode
            </code>
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            <nonce>
              NONCE1:Int
            </nonce>
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE1:AccountCode
  </code>
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  <nonce>
    NONCE1:Int
  </nonce>
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { NONCE:Int #Equals NONCE1:Int } ) )
#And ( #Not ( ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { NONCE0:Int #Equals NONCE1:Int } ) )
#And ( #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE1:AccountCode #Equals CODE:Bytes }
#And ( { NONCE1:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { CODE1:AccountCode #Equals CODE0:Bytes }
#And ( { NONCE1:Int #Equals 0 }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



Node 487:

( <generatedTop>
  <kevm>
    <k>
      #newExistingAccount #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #transferFunds WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int
      ~> #mkCreate WO:Int #newAddr ( WO:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( WO:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callStack>
          ListItem ( <callState>
            <program>
              PROGRAM_CELL:Bytes
            </program>
            <jumpDests>
              JUMPDESTS_CELL:Bytes
            </jumpDests>
            <id>
              WO:Int
            </id>
            <caller>
              CALLER_CELL:Account
            </caller>
            <callData>
              CALLDATA_CELL:Bytes
            </callData>
            <callValue>
              CALLVALUE_CELL:Int
            </callValue>
            <wordStack>
              WS:WordStack
            </wordStack>
            <localMem>
              LOCALMEM_CELL:Bytes
            </localMem>
            <pc>
              PC_CELL:Int
            </pc>
            <gas>
              GAS_CELL:Gas
            </gas>
            <memoryUsed>
              MEMORYUSED_CELL:Int
            </memoryUsed>
            <callGas>
              CALLGAS_CELL:Gas
            </callGas>
            <static>
              false
            </static>
            <callDepth>
              CALLDEPTH_CELL:Int
            </callDepth>
          </callState> ) CALLSTACK_CELL:List
        </callStack>
        <interimStates>
          ListItem ( { <accounts>
            ( <account>
              <acctID>
                #newAddr ( WO:Int , NONCE_CELL:Int )
              </acctID>
              _Gen0:BalanceCell
              _Gen1:CodeCell
              _Gen2:StorageCell
              _Gen3:OrigStorageCell
              _Gen4:TransientStorageCell
              _Gen5:NonceCell
            </account>
            ( <account>
              <acctID>
                WO:Int
              </acctID>
              <balance>
                BALANCE_CELL:Int
              </balance>
              <code>
                CODE_CELL:AccountCode
              </code>
              <storage>
                STORAGE_CELL:Map
              </storage>
              <origStorage>
                ORIG_STORAGE_CELL:Map
              </origStorage>
              <transientStorage>
                TRANSIENT_STORAGE_CELL:Map
              </transientStorage>
              <nonce>
                ( NONCE_CELL:Int +Int 1 )
              </nonce>
            </account>
            AC1_1:AccountCellMap ) )
          </accounts> | <substate>
            <selfDestruct>
              SELFDESTRUCT_CELL:Set
            </selfDestruct>
            <log>
              LOG_CELL:List
            </log>
            <refund>
              REFUND_CELL:Int
            </refund>
            <accessedAccounts>
              ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
            </accessedAccounts>
            <accessedStorage>
              ACCESSEDSTORAGE_CELL:Map
            </accessedStorage>
          </substate> } ) INTERIMSTATES_CELL:List
        </interimStates>
        <callState>
          <program>
            PROGRAM_CELL:Bytes
          </program>
          <jumpDests>
            JUMPDESTS_CELL:Bytes
          </jumpDests>
          <id>
            WO:Int
          </id>
          <caller>
            CALLER_CELL:Account
          </caller>
          <callData>
            CALLDATA_CELL:Bytes
          </callData>
          <callValue>
            CALLVALUE_CELL:Int
          </callValue>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <pc>
            PC_CELL:Int
          </pc>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            MEMORYUSED_CELL:Int
          </memoryUsed>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
        </callState>
        <substate>
          <selfDestruct>
            SELFDESTRUCT_CELL:Set
          </selfDestruct>
          <log>
            LOG_CELL:List
          </log>
          <refund>
            REFUND_CELL:Int
          </refund>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( WO:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          <accessedStorage>
            ACCESSEDSTORAGE_CELL:Map
          </accessedStorage>
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              #newAddr ( WO:Int , NONCE_CELL:Int )
            </acctID>
            _Gen0:BalanceCell
            _Gen1:CodeCell
            _Gen2:StorageCell
            _Gen3:OrigStorageCell
            _Gen4:TransientStorageCell
            _Gen5:NonceCell
          </account>
          ( <account>
            <acctID>
              WO:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            <storage>
              STORAGE_CELL:Map
            </storage>
            <origStorage>
              ORIG_STORAGE_CELL:Map
            </origStorage>
            <transientStorage>
              TRANSIENT_STORAGE_CELL:Map
            </transientStorage>
            <nonce>
              ( NONCE_CELL:Int +Int 1 )
            </nonce>
          </account>
          AC1_1:AccountCellMap ) )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { ID_CELL:Int #Equals WO:Int }
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  W0:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool <acctID>
  WO:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( notBool W0:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool WO:Int ==Int #newAddr ( WO:Int , NONCE_CELL:Int ) ) }
#And ( { true #Equals ( notBool <acctID>
  #newAddr ( WO:Int , NONCE_CELL:Int )
</acctID> in_keys ( AC1_1:AccountCellMap ) ) }
#And ( { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    #newAddr ( WO:Int , NONCE_CELL:Int )
  </acctID>
  _Gen0:BalanceCell
  _Gen1:CodeCell
  _Gen2:StorageCell
  _Gen3:OrigStorageCell
  _Gen4:TransientStorageCell
  _Gen5:NonceCell
</account>
AC1_1:AccountCellMap ) }
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE:Int
</nonce> }
#And #Exists CODE1:AccountCode . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> } ) ) )
#And ( #Not ( ( { _Gen5:NonceCell #Equals <nonce>
  NONCE0:Int
</nonce> }
#And #Exists CODE1:AccountCode . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE0:Int ==Int 0 ) ) }
#And { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> } ) ) )
#And ( #Not ( #Exists CODE1:AccountCode . #Exists NONCE1:Int . ( { true #Equals ( ( notBool CODE1:AccountCode ~> .K ==K b"" ~> .K ) orBool ( notBool NONCE1:Int ==Int 0 ) ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:AccountCode
</code> }
#And { _Gen5:NonceCell #Equals <nonce>
  NONCE1:Int
</nonce> } ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And ( #Not ( ( { _Gen1:CodeCell #Equals <code>
  CODE0:Bytes
</code> }
#And ( { _Gen3:OrigStorageCell #Equals ... }
#And ( { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> }
#And #Exists _Gen8:Map . ( { 0 #Equals lengthBytes ( CODE0:Bytes ) }
#And { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> } ) ) ) ) )
#And #Not ( #Exists _Gen8:Map . #Exists _Gen9:Map . #Exists CODE1:Bytes . ( { 0 #Equals lengthBytes ( CODE1:Bytes ) }
#And ( { _Gen1:CodeCell #Equals <code>
  CODE1:Bytes
</code> }
#And ( { _Gen2:StorageCell #Equals <storage>
  _Gen8:Map
</storage> }
#And ( { _Gen3:OrigStorageCell #Equals <origStorage>
  _Gen9:Map
</origStorage> }
#And { _Gen5:NonceCell #Equals <nonce>
  0
</nonce> } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )



