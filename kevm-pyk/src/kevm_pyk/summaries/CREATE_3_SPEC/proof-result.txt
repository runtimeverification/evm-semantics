Proof CREATE_3_SPEC Failed

┌─ 1 (root, split, init)
│   k: #next [ CREATE ] ~> K_CELL:K
│   pc: PC_CELL:Int
│   callDepth: CALLDEPTH_CELL:Int
│   statusCode: STATUSCODE_CELL:StatusCode
┃
┃ (branch)
┣━━┓ subst: .Subst
┃  ┃ constraint:
┃  ┃     ( notBool STATIC_CELL:Bool )
┃  │
┃  ├─ 3
┃  │   k: #next [ CREATE ] ~> K_CELL:K
┃  │   pc: PC_CELL:Int
┃  │   callDepth: CALLDEPTH_CELL:Int
┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  │
┃  │  (4 steps)
┃  ├─ 5 (split)
┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃  │   pc: PC_CELL:Int
┃  │   callDepth: CALLDEPTH_CELL:Int
┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┃ (branch)
┃  ┣━━┓ subst: .Subst
┃  ┃  ┃ constraint:
┃  ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃  ┃  │
┃  ┃  ├─ 7
┃  ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  │
┃  ┃  │  (3 steps)
┃  ┃  ├─ 11
┃  ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┃ (1 step)
┃  ┃  ┣━━┓
┃  ┃  ┃  │
┃  ┃  ┃  └─ 12 (leaf, pending)
┃  ┃  ┃      k: #refund CALLGAS_CELL:Gas ~> #pushCallStack ~> #pushWorldState ~> #end EVMC_BALAN ...
┃  ┃  ┃      pc: PC_CELL:Int
┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┣━━┓
┃  ┃  ┃  │
┃  ┃  ┃  ├─ 13 (split)
┃  ┃  ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ├─ 21
┃  ┃  ┃  ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  │  (1 step)
┃  ┃  ┃  ┃  ├─ 31 (split)
┃  ┃  ┃  ┃  │   k: #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int ,  ...
┃  ┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃  ┃  ┃     ( notBool #rangeNonce ( NONCE_CELL:Int ) )
┃  ┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  ┃  └─ 35 (leaf, pending)
┃  ┃  ┃  ┃  ┃      k: #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int ,  ...
┃  ┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃  ┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃  ┃
┃  ┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃  ┃     ┃     0 <=Int NONCE_CELL:Int
┃  ┃  ┃  ┃     ┃     NONCE_CELL:Int <Int maxUInt64
┃  ┃  ┃  ┃     │
┃  ┃  ┃  ┃     └─ 36 (leaf, pending)
┃  ┃  ┃  ┃         k: #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int ,  ...
┃  ┃  ┃  ┃         pc: PC_CELL:Int
┃  ┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃     ┃ constraint:
┃  ┃  ┃     ┃     1024 <=Int CALLDEPTH_CELL:Int
┃  ┃  ┃     │
┃  ┃  ┃     └─ 22 (leaf, pending)
┃  ┃  ┃         k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃  ┃  ┃         pc: PC_CELL:Int
┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┗━━┓
┃  ┃     │
┃  ┃     ├─ 14
┃  ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃  ┃     │   pc: PC_CELL:Int
┃  ┃     │   callDepth: CALLDEPTH_CELL:Int
┃  ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃     │
┃  ┃     ┊  constraint:
┃  ┃     ┊      false
┃  ┃     ┊  subst: .Subst
┃  ┃     └─ 2 (leaf, target)
┃  ┃         k: K_CELL:K
┃  ┃         pc: FINAL_PC_CELL:Int
┃  ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃  ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┗━━┓ subst: .Subst
┃     ┃ constraint: true
┃     │
┃     ├─ 8 (split)
┃     │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃     │   pc: PC_CELL:Int
┃     │   callDepth: CALLDEPTH_CELL:Int
┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┃ (branch)
┃     ┣━━┓ subst: .Subst
┃     ┃  ┃ constraint:
┃     ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃     ┃  │
┃     ┃  ├─ 9
┃     ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃     ┃  │   pc: PC_CELL:Int
┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  │
┃     ┃  │  (3 steps)
┃     ┃  ├─ 17
┃     ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃  │   pc: PC_CELL:Int
┃     ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┃ (1 step)
┃     ┃  ┣━━┓
┃     ┃  ┃  │
┃     ┃  ┃  └─ 18 (leaf, pending)
┃     ┃  ┃      k: #refund CALLGAS_CELL:Gas ~> #pushCallStack ~> #pushWorldState ~> #end EVMC_BALAN ...
┃     ┃  ┃      pc: PC_CELL:Int
┃     ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┣━━┓
┃     ┃  ┃  │
┃     ┃  ┃  ├─ 19 (split)
┃     ┃  ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃     ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃
┃     ┃  ┃  ┃ (branch)
┃     ┃  ┃  ┣━━┓ subst: .Subst
┃     ┃  ┃  ┃  ┃ constraint:
┃     ┃  ┃  ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃     ┃  ┃  ┃  │
┃     ┃  ┃  ┃  ├─ 29
┃     ┃  ┃  ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃     ┃  ┃  ┃  │   pc: PC_CELL:Int
┃     ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃  │
┃     ┃  ┃  ┃  │  (1 step)
┃     ┃  ┃  ┃  └─ 39 (leaf, pending)
┃     ┃  ┃  ┃      k: #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int ,  ...
┃     ┃  ┃  ┃      pc: PC_CELL:Int
┃     ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃  ┃
┃     ┃  ┃  ┗━━┓ subst: .Subst
┃     ┃  ┃     ┃ constraint:
┃     ┃  ┃     ┃     1024 <=Int CALLDEPTH_CELL:Int
┃     ┃  ┃     │
┃     ┃  ┃     └─ 30 (leaf, pending)
┃     ┃  ┃         k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃     ┃  ┃         pc: PC_CELL:Int
┃     ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃     ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃     ┃  ┃
┃     ┃  ┗━━┓
┃     ┃     │
┃     ┃     ├─ 20
┃     ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃     ┃     │   pc: PC_CELL:Int
┃     ┃     │   callDepth: CALLDEPTH_CELL:Int
┃     ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃     │
┃     ┃     ┊  constraint:
┃     ┃     ┊      false
┃     ┃     ┊  subst: .Subst
┃     ┃     └─ 2 (leaf, target)
┃     ┃         k: K_CELL:K
┃     ┃         pc: FINAL_PC_CELL:Int
┃     ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃     ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┗━━┓ subst: .Subst
┃        ┃ constraint: true
┃        │
┃        ├─ 10 (split)
┃        │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃        │   pc: PC_CELL:Int
┃        │   callDepth: CALLDEPTH_CELL:Int
┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┃ (branch)
┃        ┣━━┓ subst: .Subst
┃        ┃  ┃ constraint:
┃        ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃        ┃  │
┃        ┃  ├─ 15
┃        ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  │
┃        ┃  │  (3 steps)
┃        ┃  ├─ 25
┃        ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┃ (1 step)
┃        ┃  ┣━━┓
┃        ┃  ┃  │
┃        ┃  ┃  └─ 26 (leaf, pending)
┃        ┃  ┃      k: #refund CALLGAS_CELL:Gas ~> #pushCallStack ~> #pushWorldState ~> #end EVMC_BALAN ...
┃        ┃  ┃      pc: PC_CELL:Int
┃        ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┣━━┓
┃        ┃  ┃  │
┃        ┃  ┃  ├─ 27 (split)
┃        ┃  ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃        ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃
┃        ┃  ┃  ┃ (branch)
┃        ┃  ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃  ┃ constraint:
┃        ┃  ┃  ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃        ┃  ┃  ┃  │
┃        ┃  ┃  ┃  ├─ 37
┃        ┃  ┃  ┃  │   k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃        ┃  ┃  ┃  │   pc: PC_CELL:Int
┃        ┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃  │
┃        ┃  ┃  ┃  │  (1 step)
┃        ┃  ┃  ┃  └─ 46 (leaf, pending)
┃        ┃  ┃  ┃      k: #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int ,  ...
┃        ┃  ┃  ┃      pc: PC_CELL:Int
┃        ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃  ┃
┃        ┃  ┃  ┗━━┓ subst: .Subst
┃        ┃  ┃     ┃ constraint:
┃        ┃  ┃     ┃     1024 <=Int CALLDEPTH_CELL:Int
┃        ┃  ┃     │
┃        ┃  ┃     └─ 38 (leaf, pending)
┃        ┃  ┃         k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃        ┃  ┃         pc: PC_CELL:Int
┃        ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┗━━┓
┃        ┃     │
┃        ┃     ├─ 28
┃        ┃     │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃        ┃     │   pc: PC_CELL:Int
┃        ┃     │   callDepth: CALLDEPTH_CELL:Int
┃        ┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃     │
┃        ┃     ┊  constraint:
┃        ┃     ┊      false
┃        ┃     ┊  subst: .Subst
┃        ┃     └─ 2 (leaf, target)
┃        ┃         k: K_CELL:K
┃        ┃         pc: FINAL_PC_CELL:Int
┃        ┃         callDepth: FINAL_CALLDEPTH_CELL:Int
┃        ┃         statusCode: FINAL_STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┗━━┓ subst: .Subst
┃           ┃ constraint: true
┃           │
┃           ├─ 16 (split)
┃           │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃           │   pc: PC_CELL:Int
┃           │   callDepth: CALLDEPTH_CELL:Int
┃           │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃
┃           ┃ (branch)
┃           ┣━━┓ subst: .Subst
┃           ┃  ┃ constraint:
┃           ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃           ┃  │
┃           ┃  ├─ 23
┃           ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃           ┃  │   pc: PC_CELL:Int
┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  │
┃           ┃  │  (3 steps)
┃           ┃  ├─ 34
┃           ┃  │   k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃  │   pc: PC_CELL:Int
┃           ┃  │   callDepth: CALLDEPTH_CELL:Int
┃           ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┃ (1 step)
┃           ┃  ┣━━┓
┃           ┃  ┃  │
┃           ┃  ┃  └─ 40 (leaf, pending)
┃           ┃  ┃      k: #refund CALLGAS_CELL:Gas ~> #pushCallStack ~> #pushWorldState ~> #end EVMC_BALAN ...
┃           ┃  ┃      pc: PC_CELL:Int
┃           ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┣━━┓
┃           ┃  ┃  │
┃           ┃  ┃  └─ 41 (leaf, pending)
┃           ┃  ┃      k: #checkDepthExceeded ~> #checkNonceExceeded ID_CELL:Int ~> #create ID_CELL:Int #n ...
┃           ┃  ┃      pc: PC_CELL:Int
┃           ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃           ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃           ┃  ┃
┃           ┃  ┗━━┓
┃           ┃     │
┃           ┃     └─ 42 (leaf, pending)
┃           ┃         k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃           ┃         pc: PC_CELL:Int
┃           ┃         callDepth: CALLDEPTH_CELL:Int
┃           ┃         statusCode: STATUSCODE_CELL:StatusCode
┃           ┃
┃           ┗━━┓ subst: .Subst
┃              ┃ constraint: true
┃              │
┃              ├─ 24 (split)
┃              │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃              │   pc: PC_CELL:Int
┃              │   callDepth: CALLDEPTH_CELL:Int
┃              │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃
┃              ┃ (branch)
┃              ┣━━┓ subst: .Subst
┃              ┃  ┃ constraint:
┃              ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃              ┃  │
┃              ┃  ├─ 32
┃              ┃  │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃              ┃  │   pc: PC_CELL:Int
┃              ┃  │   callDepth: CALLDEPTH_CELL:Int
┃              ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃              ┃  │
┃              ┃  │  (3 steps)
┃              ┃  └─ 45 (leaf, pending)
┃              ┃      k: #checkBalanceUnderflow ID_CELL:Int W0:Int ~> #checkDepthExceeded ~> #checkNonceE ...
┃              ┃      pc: PC_CELL:Int
┃              ┃      callDepth: CALLDEPTH_CELL:Int
┃              ┃      statusCode: STATUSCODE_CELL:StatusCode
┃              ┃
┃              ┗━━┓ subst: .Subst
┃                 ┃ constraint: true
┃                 │
┃                 ├─ 33 (split)
┃                 │   k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                 │   pc: PC_CELL:Int
┃                 │   callDepth: CALLDEPTH_CELL:Int
┃                 │   statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃
┃                 ┃ (branch)
┃                 ┣━━┓ subst: .Subst
┃                 ┃  ┃ constraint:
┃                 ┃  ┃     ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > )
┃                 ┃  │
┃                 ┃  └─ 43 (leaf, pending)
┃                 ┃      k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                 ┃      pc: PC_CELL:Int
┃                 ┃      callDepth: CALLDEPTH_CELL:Int
┃                 ┃      statusCode: STATUSCODE_CELL:StatusCode
┃                 ┃
┃                 ┗━━┓ subst: .Subst
┃                    ┃ constraint: true
┃                    │
┃                    └─ 44 (leaf, pending)
┃                        k: CREATE W0:Int W1:Int W2:Int ~> #pc [ CREATE ] ~> K_CELL:K
┃                        pc: PC_CELL:Int
┃                        callDepth: CALLDEPTH_CELL:Int
┃                        statusCode: STATUSCODE_CELL:StatusCode
┃
┗━━┓ subst: .Subst
   ┃ constraint:
   ┃     STATIC_CELL:Bool
   │
   ├─ 4
   │   k: #next [ CREATE ] ~> K_CELL:K
   │   pc: PC_CELL:Int
   │   callDepth: CALLDEPTH_CELL:Int
   │   statusCode: STATUSCODE_CELL:StatusCode
   │
   │  (2 steps)
   └─ 6 (leaf, terminal)
       k: #halt ~> K_CELL:K
       pc: PC_CELL:Int
       callDepth: CALLDEPTH_CELL:Int
       statusCode: EVMC_STATIC_MODE_VIOLATION



Node 1:

( <generatedTop>
  <kevm>
    <k>
      #next [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } )



Node 2:

...



Node 3:

( <generatedTop>
  <kevm>
    <k>
      #next [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { STATIC_CELL:Bool #Equals false }
#And { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } ) )



Node 4:

( <generatedTop>
  <kevm>
    <k>
      #next [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { STATIC_CELL:Bool #Equals true }
#And { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } ) )



Node 5:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 6:

( <generatedTop>
  <kevm>
    <k>
      #halt
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <statusCode>
          EVMC_STATIC_MODE_VIOLATION
        </statusCode>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : WS:WordStack ) ) )
          </wordStack>
          <static>
            true
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals STATIC_CELL:Bool }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 7:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 8:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 9:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 10:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 11:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 12:

( <generatedTop>
  <kevm>
    <k>
      #refund CALLGAS_CELL:Gas
      ~> #pushCallStack
      ~> #pushWorldState
      ~> #end EVMC_BALANCE_UNDERFLOW
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 13:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 14:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals BALANCE_CELL:Int <Int W0:Int } ) )
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals W0:Int <=Int BALANCE_CELL:Int } ) )
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 15:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 16:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 17:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 18:

( <generatedTop>
  <kevm>
    <k>
      #refund CALLGAS_CELL:Gas
      ~> #pushCallStack
      ~> #pushWorldState
      ~> #end EVMC_BALANCE_UNDERFLOW
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 19:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 20:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals BALANCE_CELL:Int <Int W0:Int } ) )
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals W0:Int <=Int BALANCE_CELL:Int } ) )
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 21:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 22:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 23:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 24:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 25:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 26:

( <generatedTop>
  <kevm>
    <k>
      #refund CALLGAS_CELL:Gas
      ~> #pushCallStack
      ~> #pushWorldState
      ~> #end EVMC_BALANCE_UNDERFLOW
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 27:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 28:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals BALANCE_CELL:Int <Int W0:Int } ) )
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals W0:Int <=Int BALANCE_CELL:Int } ) )
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 29:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 30:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 31:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 32:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 33:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 34:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 35:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals #rangeNonce ( NONCE_CELL:Int ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) )



Node 36:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals 0 <=Int NONCE_CELL:Int }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals NONCE_CELL:Int <Int maxUInt64 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) ) ) )



Node 37:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 38:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 39:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



Node 40:

( <generatedTop>
  <kevm>
    <k>
      #refund CALLGAS_CELL:Gas
      ~> #pushCallStack
      ~> #pushWorldState
      ~> #end EVMC_BALANCE_UNDERFLOW
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <output>
          b""
        </output>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <callGas>
            CALLGAS_CELL:Gas
          </callGas>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W0:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 41:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 42:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals BALANCE_CELL:Int <Int W0:Int } ) )
#And ( #Not ( ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And { true #Equals W0:Int <=Int BALANCE_CELL:Int } ) )
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) )



Node 43:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 44:

( <generatedTop>
  <kevm>
    <k>
      CREATE W0:Int W1:Int W2:Int
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <static>
            false
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) } ) )



Node 45:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W0:Int
      ~> #checkDepthExceeded
      ~> #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) )



Node 46:

( <generatedTop>
  <kevm>
    <k>
      #checkNonceExceeded ID_CELL:Int
      ~> #create ID_CELL:Int #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) W0:Int #range ( LOCALMEM_CELL:Bytes , W1:Int , W2:Int )
      ~> #codeDeposit #newAddr ( ID_CELL:Int , NONCE_CELL:Int )
      ~> #pc [ CREATE ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            false
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <nonce>
              NONCE_CELL:Int
            </nonce>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( #Ceil ( #newAddr ( ID_CELL:Int , NONCE_CELL:Int ) )
#And ( { true #Equals ( notBool STATIC_CELL:Bool ) }
#And ( { true #Equals W0:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( ( notBool Ghasmaxinitcodesize << SCHEDULE_CELL:Schedule >> ) orBool W2:Int <=Int maxInitCodeSize < SCHEDULE_CELL:Schedule > ) } ) ) ) ) ) )



