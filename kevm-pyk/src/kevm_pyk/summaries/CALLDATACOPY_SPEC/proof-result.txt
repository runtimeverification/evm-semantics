Proof CALLDATACOPY_SPEC Failed

┌─ 1 (root, split, init)
│   k: #next [ CALLDATACOPY ] ~> _K_CELL:K
│   pc: _PC_CELL:Int
│   callDepth: _CALLDEPTH_CELL:Int
│   statusCode: _STATUSCODE_CELL:StatusCode
┃
┃ (branch)
┣━━┓ subst: .Subst
┃  ┃ constraint:
┃  ┃     #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) <Int 3
┃  │
┃  └─ 3 (leaf, pending)
┃      k: #next [ CALLDATACOPY ] ~> _K_CELL:K
┃      pc: _PC_CELL:Int
┃      callDepth: _CALLDEPTH_CELL:Int
┃      statusCode: _STATUSCODE_CELL:StatusCode
┃
┣━━┓ subst: .Subst
┃  ┃ constraint:
┃  ┃     ( #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) +Int -3 ) >Int 1024
┃  │
┃  └─ 4 (leaf, pending)
┃      k: #next [ CALLDATACOPY ] ~> _K_CELL:K
┃      pc: _PC_CELL:Int
┃      callDepth: _CALLDEPTH_CELL:Int
┃      statusCode: _STATUSCODE_CELL:StatusCode
┃
┗━━┓ subst: .Subst
   ┃ constraint:
   ┃     ( notBool #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) <Int 3 )
   ┃     ( notBool ( #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) +Int -3 ) >Int 1024 )
   │
   └─ 5 (leaf, pending)
       k: #next [ CALLDATACOPY ] ~> _K_CELL:K
       pc: _PC_CELL:Int
       callDepth: _CALLDEPTH_CELL:Int
       statusCode: _STATUSCODE_CELL:StatusCode


┌─ 2 (root, leaf, target)
│   k: _K_CELL:K
│   pc: ?_FINAL_PC_CELL:Int
│   callDepth: ?_FINAL_CALLDEPTH_CELL:Int
│   statusCode: ?_FINAL_STATUSCODE_CELL:StatusCode


Node 1:

<generatedTop>
  <kevm>
    <k>
      #next [ CALLDATACOPY ]
      ~> _K_CELL:K
    </k>
    ...
  </kevm>
  ...
</generatedTop>



Node 2:

...



Node 3:

( <generatedTop>
  <kevm>
    <k>
      #next [ CALLDATACOPY ]
      ~> _K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <wordStack>
            _WORDSTACK_CELL:WordStack
          </wordStack>
          ...
        </callState>
        ...
      </evm>
      ...
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And { true #Equals #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) <Int 3 } )



Node 4:

( <generatedTop>
  <kevm>
    <k>
      #next [ CALLDATACOPY ]
      ~> _K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <wordStack>
            _WORDSTACK_CELL:WordStack
          </wordStack>
          ...
        </callState>
        ...
      </evm>
      ...
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And { true #Equals ( #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) +Int -3 ) >Int 1024 } )



Node 5:

( <generatedTop>
  <kevm>
    <k>
      #next [ CALLDATACOPY ]
      ~> _K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <wordStack>
            _WORDSTACK_CELL:WordStack
          </wordStack>
          ...
        </callState>
        ...
      </evm>
      ...
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { false #Equals #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) <Int 3 }
#And { false #Equals ( #sizeWordStack ( _WORDSTACK_CELL:WordStack , 0 ) +Int -3 ) >Int 1024 } ) )



