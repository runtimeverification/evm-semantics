Proof CALL_7_SPEC Failed

┌─ 1 (root, split, init)
│   k: #next [ CALL ] ~> K_CELL:K
│   pc: PC_CELL:Int
│   callDepth: CALLDEPTH_CELL:Int
│   statusCode: STATUSCODE_CELL:StatusCode
┃
┃ (branch)
┣━━┓ subst: .Subst
┃  ┃ constraint:
┃  ┃     ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) )
┃  │
┃  ├─ 3
┃  │   k: #next [ CALL ] ~> K_CELL:K
┃  │   pc: PC_CELL:Int
┃  │   callDepth: CALLDEPTH_CELL:Int
┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  │
┃  │  (3 steps)
┃  ├─ 5 (split)
┃  │   k: #gas [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W ...
┃  │   pc: PC_CELL:Int
┃  │   callDepth: CALLDEPTH_CELL:Int
┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┃ (branch)
┃  ┣━━┓ subst: .Subst
┃  ┃  ┃ constraint:
┃  ┃  ┃     USEGAS_CELL:Bool
┃  ┃  │
┃  ┃  ├─ 7
┃  ┃  │   k: #gas [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W ...
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  │
┃  ┃  │  (4 steps)
┃  ┃  ├─ 12 (split)
┃  ┃  │   k: ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMO ...
┃  ┃  │   pc: PC_CELL:Int
┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┃ (branch)
┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃     ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) <=Gas GAS_CELL:Gas
┃  ┃  ┃  │
┃  ┃  ┃  ├─ 13
┃  ┃  ┃  │   k: ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMO ...
┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  │
┃  ┃  ┃  │  (4 steps)
┃  ┃  ┃  ├─ 19 (split)
┃  ┃  ┃  │   k: #accountNonexistent ( ( W1:Int modInt pow160 ) ) ~> #freezerCcallgas1_ ( SCHEDUL ...
┃  ┃  ┃  │   pc: PC_CELL:Int
┃  ┃  ┃  │   callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┃ (branch)
┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃  ┃     ID_CELL:Int ==Int ( W1:Int modInt pow160 )
┃  ┃  ┃  ┃  ┃     ( notBool <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  └─ 23 (leaf, pending)
┃  ┃  ┃  ┃      k: #accountNonexistent ( ( W1:Int modInt pow160 ) ) ~> #freezerCcallgas1_ ( SCHEDUL ...
┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┣━━┓ subst: .Subst
┃  ┃  ┃  ┃  ┃ constraint:
┃  ┃  ┃  ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃  ┃  ┃  ┃     ( notBool ID_CELL:Int ==Int ( W1:Int modInt pow160 ) )
┃  ┃  ┃  ┃  ┃     ( notBool <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃  ┃  ┃  ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ( W1:Int modInt pow160 )
  </acctID>
  <balance>
    BAL:Int
  </balance>
  <code>
    CODE:AccountCode
  </code>
  _Gen0:StorageCell
  _Gen1:OrigStorageCell
  _Gen2:TransientStorageCell
  <nonce>
    NONCE:Int
  </nonce>
</account>
AC1_1:AccountCellMap )
┃  ┃  ┃  ┃  │
┃  ┃  ┃  ┃  └─ 24 (leaf, pending)
┃  ┃  ┃  ┃      k: #accountNonexistent ( ( W1:Int modInt pow160 ) ) ~> #freezerCcallgas1_ ( SCHEDUL ...
┃  ┃  ┃  ┃      pc: PC_CELL:Int
┃  ┃  ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃  ┃
┃  ┃  ┃  ┗━━┓ subst: .Subst
┃  ┃  ┃     ┃ constraint: true
┃  ┃  ┃     │
┃  ┃  ┃     └─ 25 (leaf, pending)
┃  ┃  ┃         k: #accountNonexistent ( ( W1:Int modInt pow160 ) ) ~> #freezerCcallgas1_ ( SCHEDUL ...
┃  ┃  ┃         pc: PC_CELL:Int
┃  ┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃  ┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃  ┃
┃  ┃  ┗━━┓ subst: .Subst
┃  ┃     ┃ constraint:
┃  ┃     ┃     GAS_CELL:Gas <Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
┃  ┃     │
┃  ┃     └─ 14 (leaf, pending)
┃  ┃         k: ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMO ...
┃  ┃         pc: PC_CELL:Int
┃  ┃         callDepth: CALLDEPTH_CELL:Int
┃  ┃         statusCode: STATUSCODE_CELL:StatusCode
┃  ┃
┃  ┗━━┓ subst: .Subst
┃     ┃ constraint:
┃     ┃     ( notBool USEGAS_CELL:Bool )
┃     │
┃     ├─ 8
┃     │   k: #gas [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W ...
┃     │   pc: PC_CELL:Int
┃     │   callDepth: CALLDEPTH_CELL:Int
┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     │
┃     │  (4 steps)
┃     ├─ 9 (split)
┃     │   k: #checkBalanceUnderflow ID_CELL:Int W2:Int ~> #checkDepthExceeded ~> #call ID_CEL ...
┃     │   pc: PC_CELL:Int
┃     │   callDepth: CALLDEPTH_CELL:Int
┃     │   statusCode: STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┃ (branch)
┃     ┣━━┓ subst: .Subst
┃     ┃  ┃ constraint:
┃     ┃  ┃     BALANCE_CELL:Int <Int W2:Int
┃     ┃  │
┃     ┃  └─ 10 (leaf, pending)
┃     ┃      k: #checkBalanceUnderflow ID_CELL:Int W2:Int ~> #checkDepthExceeded ~> #call ID_CEL ...
┃     ┃      pc: PC_CELL:Int
┃     ┃      callDepth: CALLDEPTH_CELL:Int
┃     ┃      statusCode: STATUSCODE_CELL:StatusCode
┃     ┃
┃     ┗━━┓ subst: .Subst
┃        ┃ constraint:
┃        ┃     W2:Int <=Int BALANCE_CELL:Int
┃        │
┃        ├─ 11
┃        │   k: #checkBalanceUnderflow ID_CELL:Int W2:Int ~> #checkDepthExceeded ~> #call ID_CEL ...
┃        │   pc: PC_CELL:Int
┃        │   callDepth: CALLDEPTH_CELL:Int
┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        │
┃        │  (1 step)
┃        ├─ 15 (split)
┃        │   k: #checkDepthExceeded ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modIn ...
┃        │   pc: PC_CELL:Int
┃        │   callDepth: CALLDEPTH_CELL:Int
┃        │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┃ (branch)
┃        ┣━━┓ subst: .Subst
┃        ┃  ┃ constraint:
┃        ┃  ┃     CALLDEPTH_CELL:Int <Int 1024
┃        ┃  │
┃        ┃  ├─ 16
┃        ┃  │   k: #checkDepthExceeded ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modIn ...
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  │
┃        ┃  │  (1 step)
┃        ┃  ├─ 18 (split)
┃        ┃  │   k: #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:In ...
┃        ┃  │   pc: PC_CELL:Int
┃        ┃  │   callDepth: CALLDEPTH_CELL:Int
┃        ┃  │   statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┃ (branch)
┃        ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃ constraint:
┃        ┃  ┃  ┃     CODE_CELL:AccountCode ==K CODE:Bytes
┃        ┃  ┃  ┃     ID_CELL:Int ==Int ( W1:Int modInt pow160 )
┃        ┃  ┃  ┃     ( notBool <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( DotAccountVar:AccountCellMap ) )
┃        ┃  ┃  │
┃        ┃  ┃  └─ 20 (leaf, pending)
┃        ┃  ┃      k: #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:In ...
┃        ┃  ┃      pc: PC_CELL:Int
┃        ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┣━━┓ subst: .Subst
┃        ┃  ┃  ┃ constraint:
┃        ┃  ┃  ┃     ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃  ┃  ┃     ( notBool ID_CELL:Int ==Int ( W1:Int modInt pow160 ) )
┃        ┃  ┃  ┃     ( notBool <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( AC1_1:AccountCellMap ) )
┃        ┃  ┃  ┃     DotAccountVar:AccountCellMap ==K ( <account>
  <acctID>
    ( W1:Int modInt pow160 )
  </acctID>
  _Gen0:BalanceCell
  <code>
    CODE:Bytes
  </code>
  _Gen1:StorageCell
  _Gen2:OrigStorageCell
  _Gen3:TransientStorageCell
  _Gen4:NonceCell
</account>
AC1_1:AccountCellMap )
┃        ┃  ┃  │
┃        ┃  ┃  └─ 21 (leaf, pending)
┃        ┃  ┃      k: #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:In ...
┃        ┃  ┃      pc: PC_CELL:Int
┃        ┃  ┃      callDepth: CALLDEPTH_CELL:Int
┃        ┃  ┃      statusCode: STATUSCODE_CELL:StatusCode
┃        ┃  ┃
┃        ┃  ┗━━┓ subst: .Subst
┃        ┃     ┃ constraint: true
┃        ┃     │
┃        ┃     └─ 22 (leaf, pending)
┃        ┃         k: #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:In ...
┃        ┃         pc: PC_CELL:Int
┃        ┃         callDepth: CALLDEPTH_CELL:Int
┃        ┃         statusCode: STATUSCODE_CELL:StatusCode
┃        ┃
┃        ┗━━┓ subst: .Subst
┃           ┃ constraint:
┃           ┃     1024 <=Int CALLDEPTH_CELL:Int
┃           │
┃           └─ 17 (leaf, pending)
┃               k: #checkDepthExceeded ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modIn ...
┃               pc: PC_CELL:Int
┃               callDepth: CALLDEPTH_CELL:Int
┃               statusCode: STATUSCODE_CELL:StatusCode
┃
┗━━┓ subst: .Subst
   ┃ constraint:
   ┃     STATIC_CELL:Bool
   ┃     #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) )
   │
   ├─ 4
   │   k: #next [ CALL ] ~> K_CELL:K
   │   pc: PC_CELL:Int
   │   callDepth: CALLDEPTH_CELL:Int
   │   statusCode: STATUSCODE_CELL:StatusCode
   │
   │  (2 steps)
   └─ 6 (leaf, terminal)
       k: #halt ~> K_CELL:K
       pc: PC_CELL:Int
       callDepth: CALLDEPTH_CELL:Int
       statusCode: EVMC_STATIC_MODE_VIOLATION


┌─ 2 (root, leaf, target)
│   k: K_CELL:K
│   pc: FINAL_PC_CELL:Int
│   callDepth: FINAL_CALLDEPTH_CELL:Int
│   statusCode: FINAL_STATUSCODE_CELL:StatusCode


Node 1:

( <generatedTop>
  <kevm>
    <k>
      #next [ CALL ]
      ~> K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) )
          </wordStack>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) } )



Node 2:

...



Node 3:

( <generatedTop>
  <kevm>
    <k>
      #next [ CALL ]
      ~> K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) )
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And { false #Equals ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) } ) )



Node 4:

( <generatedTop>
  <kevm>
    <k>
      #next [ CALL ]
      ~> K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) )
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { STATIC_CELL:Bool #Equals true }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And { true #Equals #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) } ) ) )



Node 5:

( <generatedTop>
  <kevm>
    <k>
      #gas [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) )



Node 6:

( <generatedTop>
  <kevm>
    <k>
      #halt
      ~> K_CELL:K
    </k>
    <ethereum>
      <evm>
        <statusCode>
          EVMC_STATIC_MODE_VIOLATION
        </statusCode>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) )
          </wordStack>
          <static>
            true
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals STATIC_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) } ) ) )



Node 7:

( <generatedTop>
  <kevm>
    <k>
      #gas [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      USEGAS_CELL:Bool
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { USEGAS_CELL:Bool #Equals true }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) )



Node 8:

( <generatedTop>
  <kevm>
    <k>
      #gas [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      USEGAS_CELL:Bool
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { USEGAS_CELL:Bool #Equals false }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) )



Node 9:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W2:Int
      ~> #checkDepthExceeded
      ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) )



Node 10:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W2:Int
      ~> #checkDepthExceeded
      ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals BALANCE_CELL:Int <Int W2:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



Node 11:

( <generatedTop>
  <kevm>
    <k>
      #checkBalanceUnderflow ID_CELL:Int W2:Int
      ~> #checkDepthExceeded
      ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



Node 12:

( <generatedTop>
  <kevm>
    <k>
      ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
      ~> #deductGas
      ~> #gas [ CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) )



Node 13:

( <generatedTop>
  <kevm>
    <k>
      ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
      ~> #deductGas
      ~> #gas [ CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) <=Gas GAS_CELL:Gas }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



Node 14:

( <generatedTop>
  <kevm>
    <k>
      ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
      ~> #deductGas
      ~> #gas [ CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <gas>
            GAS_CELL:Gas
          </gas>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals GAS_CELL:Gas <Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



Node 15:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



Node 16:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) )



Node 17:

( <generatedTop>
  <kevm>
    <k>
      #checkDepthExceeded
      ~> #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals 1024 <=Int CALLDEPTH_CELL:Int }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) )



Node 18:

( <generatedTop>
  <kevm>
    <k>
      #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) )



Node 19:

( <generatedTop>
  <kevm>
    <k>
      #accountNonexistent ( ( W1:Int modInt pow160 ) )
      ~> #freezerCcallgas1_ ( SCHEDULE_CELL:Schedule ~> .K , W0:Int ~> .K , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) ~> .K , W2:Int ~> .K , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set ~> .K )
      ~> #allocateCallGas
      ~> Ccall ( SCHEDULE_CELL:Schedule , #accountNonexistent ( ( W1:Int modInt pow160 ) ) , W0:Int , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) , W2:Int , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set )
      ~> #deductGas
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <gas>
            GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
          </gas>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) <=Gas GAS_CELL:Gas }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



Node 20:

( <generatedTop>
  <kevm>
    <k>
      #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            <code>
              CODE_CELL:AccountCode
            </code>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { CODE_CELL:AccountCode #Equals CODE:Bytes }
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { ID_CELL:Int #Equals ( W1:Int modInt pow160 ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) ) ) ) )



Node 21:

( <generatedTop>
  <kevm>
    <k>
      #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { ID_CELL:Int #Equals ( W1:Int modInt pow160 ) } )
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ( W1:Int modInt pow160 )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) ) ) ) ) )



Node 22:

( <generatedTop>
  <kevm>
    <k>
      #call ID_CELL:Int ( W1:Int modInt pow160 ) ( W1:Int modInt pow160 ) W2:Int W2:Int #range ( LOCALMEM_CELL:Bytes , W3:Int , W4:Int ) false
      ~> #return W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <useGas>
      false
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <localMem>
            LOCALMEM_CELL:Bytes
          </localMem>
          <static>
            STATIC_CELL:Bool
          </static>
          <callDepth>
            CALLDEPTH_CELL:Int
          </callDepth>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set |Set SetItem ( ( W1:Int modInt pow160 ) )
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            <balance>
              BALANCE_CELL:Int
            </balance>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals ( notBool USEGAS_CELL:Bool ) }
#And ( { true #Equals W2:Int <=Int BALANCE_CELL:Int }
#And ( { true #Equals CALLDEPTH_CELL:Int <Int 1024 }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) )



Node 23:

( <generatedTop>
  <kevm>
    <k>
      #accountNonexistent ( ( W1:Int modInt pow160 ) )
      ~> #freezerCcallgas1_ ( SCHEDULE_CELL:Schedule ~> .K , W0:Int ~> .K , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) ~> .K , W2:Int ~> .K , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set ~> .K )
      ~> #allocateCallGas
      ~> Ccall ( SCHEDULE_CELL:Schedule , #accountNonexistent ( ( W1:Int modInt pow160 ) ) , W0:Int , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) , W2:Int , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set )
      ~> #deductGas
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <gas>
            GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
          </gas>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { ID_CELL:Int #Equals ( W1:Int modInt pow160 ) }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( DotAccountVar:AccountCellMap ) }
#And ( { true #Equals ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) <=Gas GAS_CELL:Gas }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) ) )



Node 24:

( <generatedTop>
  <kevm>
    <k>
      #accountNonexistent ( ( W1:Int modInt pow160 ) )
      ~> #freezerCcallgas1_ ( SCHEDULE_CELL:Schedule ~> .K , W0:Int ~> .K , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) ~> .K , W2:Int ~> .K , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set ~> .K )
      ~> #allocateCallGas
      ~> Ccall ( SCHEDULE_CELL:Schedule , #accountNonexistent ( ( W1:Int modInt pow160 ) ) , W0:Int , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) , W2:Int , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set )
      ~> #deductGas
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <gas>
            GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
          </gas>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { false #Equals <acctID>
  ID_CELL:Int
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( #Not ( { ID_CELL:Int #Equals ( W1:Int modInt pow160 ) } )
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { false #Equals <acctID>
  ( W1:Int modInt pow160 )
</acctID> in_keys ( AC1_1:AccountCellMap ) }
#And ( { true #Equals ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) <=Gas GAS_CELL:Gas }
#And ( { DotAccountVar:AccountCellMap #Equals ( <account>
  <acctID>
    ( W1:Int modInt pow160 )
  </acctID>
  ...
</account>
AC1_1:AccountCellMap ) }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) ) ) ) ) )



Node 25:

( <generatedTop>
  <kevm>
    <k>
      #accountNonexistent ( ( W1:Int modInt pow160 ) )
      ~> #freezerCcallgas1_ ( SCHEDULE_CELL:Schedule ~> .K , W0:Int ~> .K , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) ~> .K , W2:Int ~> .K , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set ~> .K )
      ~> #allocateCallGas
      ~> Ccall ( SCHEDULE_CELL:Schedule , #accountNonexistent ( ( W1:Int modInt pow160 ) ) , W0:Int , GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) , W2:Int , ( W1:Int modInt pow160 ) in ACCESSEDACCOUNTS_CELL:Set )
      ~> #deductGas
      ~> #access [ CALL , CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int ]
      ~> CALL W0:Int ( W1:Int modInt pow160 ) W2:Int W3:Int W4:Int W5:Int W6:Int
      ~> #pc [ CALL ]
      ~> K_CELL:K
    </k>
    <schedule>
      SCHEDULE_CELL:Schedule
    </schedule>
    <useGas>
      true
    </useGas>
    <ethereum>
      <evm>
        <callState>
          <id>
            ID_CELL:Int
          </id>
          <wordStack>
            WS:WordStack
          </wordStack>
          <gas>
            GAS_CELL:Gas -Gas ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) )
          </gas>
          <memoryUsed>
            #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int )
          </memoryUsed>
          <static>
            STATIC_CELL:Bool
          </static>
          ...
        </callState>
        <substate>
          <accessedAccounts>
            ACCESSEDACCOUNTS_CELL:Set
          </accessedAccounts>
          ...
        </substate>
        ...
      </evm>
      <network>
        <accounts>
          ( <account>
            <acctID>
              ID_CELL:Int
            </acctID>
            ...
          </account>
          DotAccountVar:AccountCellMap )
        </accounts>
        ...
      </network>
    </ethereum>
    ...
  </kevm>
  ...
</generatedTop>
#And ( { true #Equals USEGAS_CELL:Bool }
#And ( { true #Equals ( notBool <acctID>
  ID_CELL:Int
</acctID> in_keys ( DotAccountVar:AccountCellMap ) ) }
#And ( { true #Equals ( Cmem ( SCHEDULE_CELL:Schedule , #memoryUsageUpdate ( #memoryUsageUpdate ( MEMORYUSED_CELL:Int , W3:Int , W4:Int ) , W5:Int , W6:Int ) ) -Int Cmem ( SCHEDULE_CELL:Schedule , MEMORYUSED_CELL:Int ) ) <=Gas GAS_CELL:Gas }
#And { true #Equals ( notBool ( STATIC_CELL:Bool andBool #changesState ( CALL , ( W0:Int : ( W1:Int : ( W2:Int : ( W3:Int : ( W4:Int : ( W5:Int : ( W6:Int : WS:WordStack ) ) ) ) ) ) ) ) ) ) } ) ) ) )



