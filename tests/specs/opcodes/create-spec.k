requires "verification.k"

/*

`CREATE VALUE MEMSTART MEMWIDTH` will return (push into the stack) `#newAddr(ACCT_ID, NONCE)` and update the network state (see network cell).

`#generatedCode` is the runtime bytecode of the newly created contract
that is generated by executing the contract creation bytecode provided by #range(#mapWithCode, #memStart, #memWidth)`.

#mapWithCode, #memStart, #memWidth are placeholders. They can be instantiated with concrete values when used in other proofs.

*/


module CREATE-SPEC
    imports VERIFICATION

    claim <kevm>
            <k> #next [ CREATE ] => . ... </k>
            <exit-code> 1 </exit-code>
            <mode> NORMAL </mode>
            <schedule> PETERSBURG </schedule>
            <ethereum>
              <evm>
                <output> _ => .ByteArray </output>
                <statusCode> _ => EVMC_SUCCESS </statusCode>
                <callStack> _ </callStack>
                <interimStates> _ </interimStates>
                <touchedAccounts> _ => ?_ </touchedAccounts>

                <callState>
                  <program> _ </program>
                  <jumpDests> _ </jumpDests>

                  <id> ACCT_ID </id>
                  <caller> _ </caller> // who called this contract; in the begining, origin // msg.sender
                  <callData> _ </callData>
                  <callValue> _ </callValue>

                  <wordStack>
                    VALUE : #memStart : #memWidth : WS => #newAddr(ACCT_ID, NONCE) : WS
                  </wordStack>
                  <localMem> #mapWithCode </localMem>
                  <pc>
                    PCOUNT => ( PCOUNT +Int 1 )
                  </pc>
                  <gas>
                    G => ?_
                  </gas>
                  <memoryUsed> MU => ?_ </memoryUsed>
                  <callGas> _ => ?_ </callGas>

                  <static> false </static>
                  <callDepth> CALL_DEPTH </callDepth>
                </callState>
                <substate>
                  <accessedAccounts> _ => ?_  </accessedAccounts>
                  ...
                </substate>
                ...
              </evm>
              <network>
                <chainID> _ </chainID>

                <activeAccounts> SetItem(ACCT_ID) ACCTS:Set (.Set => SetItem(#newAddr(ACCT_ID, NONCE))) </activeAccounts>
                <accounts>
                  <account>
                    <acctID> ACCT_ID </acctID>
                    <balance> BAL => BAL -Int VALUE </balance>
                    <nonce> NONCE => NONCE +Int 1 </nonce>
                    ...
                  </account>
                  ( .Bag
                 => <account>
                      <acctID>  #newAddr(ACCT_ID, NONCE) </acctID>
                      <balance> VALUE </balance>
                      <nonce> 1 </nonce>
                      <code> #generatedCode </code>
                      ...
                    </account>
                  )
                  REST
                </accounts>

                <txOrder> _ </txOrder>
                <txPending> _ </txPending>
                <messages> _ </messages>
              </network>
            </ethereum>
            ...
          </kevm>
      requires G -Int (Cmem(PETERSBURG, #memoryUsageUpdate(MU, #memStart, #memWidth)) -Int Cmem(PETERSBURG, MU)) -Int 32000 >Int 0
       andBool 0 <=Int CALL_DEPTH andBool CALL_DEPTH <Int 1023
       andBool #rangeUInt(256, VALUE)
       andBool #rangeUInt(256, BAL)
       andBool #rangeNonce(NONCE)
       andBool BAL >=Int VALUE
       andBool notBool (#newAddr(ACCT_ID, NONCE) in (SetItem(ACCT_ID) ACCTS))
       andBool ACCT_ID =/=Int #newAddr(ACCT_ID, NONCE)
       // 900 is a random value
       andBool #range(0 <= #sizeWordStack(WS) <= 900)

    claim <kevm>
            <k> #execute => #halt ... </k>
            <exit-code> 1 </exit-code>
            <mode> NORMAL </mode>
            <schedule> PETERSBURG </schedule>
            <ethereum>
              <evm>
                <output> _ => #generatedCode </output>
                <statusCode> _ => EVMC_SUCCESS </statusCode>
                <callStack> _ </callStack>
                <interimStates> _ </interimStates>
                <touchedAccounts> _ => ?_ </touchedAccounts>

                <callState>
                  <program> #range(#mapWithCode, #memStart, #memWidth) </program>
                  <jumpDests> _ </jumpDests>

                  <id> ACCT_ID </id>
                  <caller> _ </caller> // who called this contract; in the begining, origin // msg.sender
                  <callData> _ </callData>
                  <callValue> _ </callValue>

                  <wordStack> .WordStack => ?_ </wordStack>
                  <localMem> .Memory => ?_ </localMem>
                  <pc> 0 => ?_ </pc>
                  // simplified gas cost
                  <gas> G => 0 </gas>
                  <memoryUsed> MU => ?_ </memoryUsed>
                  <callGas> _ => ?_ </callGas>

                  <static> false </static>
                  <callDepth> CALL_DEPTH </callDepth>
                </callState>
                <substate>
                  <accessedAccounts> _ => ?_  </accessedAccounts>
                  ...
                </substate>
                ...
              </evm>
              <network>
                <chainID> _ </chainID>

                <activeAccounts> SetItem(ACCT_ID) ACCTS:Set </activeAccounts>
                <accounts> _ </accounts>

                <txOrder> _ </txOrder>
                <txPending> _ </txPending>
                <messages> _ </messages>
              </network>
            </ethereum>
            ...
          </kevm>
      requires 0 <=Int CALL_DEPTH andBool CALL_DEPTH <Int 1024  [trusted, matching(#range)]

endmodule
